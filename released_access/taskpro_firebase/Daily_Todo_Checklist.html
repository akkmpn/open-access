<!DOCTYPE html>
<html lang="en" data-theme="dark" data-design="default">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Enterprise TaskPro - ver9.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Playfair+Display:wght@400;700&family=Roboto+Mono:wght@400;700&family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <style>
        /* ==================== 1. CORE VARIABLES ==================== */
        :root {
            --bg-body: #0f172a;
            --bg-sidebar: #1e293b;
            --bg-card: #334155;
            --bg-input: #1e293b;
            --bg-hover: rgba(255,255,255,0.05);
            --accent: #208084;
            --accent-hover: #2ba8ad;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --border: #475569;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --streak-fire: #f97316;
            --streak-target: #8b5cf6;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --radius: 12px;
            --font-main: 'Inter', sans-serif;
            --border-width: 1px;
            --sidebar-width: 260px;
        }

        [data-theme="light"] {
            --bg-body: #f1f5f9;
            --bg-sidebar: #ffffff;
            --bg-card: #ffffff;
            --bg-input: #f8fafc;
            --bg-hover: #f1f5f9;
            --text-main: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: var(--font-main);
            background: var(--bg-body);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            transition: background 0.3s, color 0.3s;
        }

        /* ==================== SIDEBAR ==================== */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-sidebar);
            border-right: var(--border-width) solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            transition: transform 0.3s ease;
            z-index: 50;
            flex-shrink: 0;
        }
        
        .logo { font-size: 20px; font-weight: 800; color: var(--text-main); margin-bottom: 30px; display: flex; align-items: center; gap: 10px; }
        .logo i { color: var(--accent); }

        .nav-link {
            display: flex; align-items: center; gap: 12px; padding: 12px 15px;
            color: var(--text-muted); text-decoration: none; border-radius: var(--radius);
            margin-bottom: 5px; transition: 0.2s; cursor: pointer; font-size: 14px; font-weight: 500;
            border: var(--border-width) solid transparent; background: none; width: 100%; text-align: left;
            font-family: var(--font-main);
        }
        .nav-link:hover { background: var(--bg-hover); color: var(--text-main); }
        .nav-link.active { background: var(--accent); color: white; box-shadow: var(--shadow); border-color: var(--accent); }

        .sidebar-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 40; display: none; backdrop-filter: blur(2px); }

        /* ==================== MAIN CONTENT ==================== */
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; width: 100%; }

        /* HEADER */
        .header {
            height: 70px;
            border-bottom: var(--border-width) solid var(--border);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; background: var(--bg-body); transition: background 0.3s; flex-shrink: 0;
        }
        
        .weather-widget { font-size: 11px; display: flex; flex-direction: column; text-align: right; color: var(--text-muted); margin-right: 15px; }
        .weather-info { display: flex; align-items: center; gap: 6px; color: var(--text-main); font-weight: 600; }

        .menu-btn { display: none; background: none; border: none; color: var(--text-main); font-size: 20px; cursor: pointer; padding: 5px; }
        .header-actions { display: flex; align-items: center; gap: 10px; }
        .icon-btn-header {
            background: var(--bg-card); border: var(--border-width) solid var(--border); color: var(--text-muted);
            width: 36px; height: 36px; border-radius: var(--radius); display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s; box-shadow: var(--shadow);
        }
        .icon-btn-header:hover { color: var(--accent); border-color: var(--accent); }

        /* VIEWS */
        .view-container { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 20px; display: none; animation: fadeIn 0.3s ease; }
        .view-container.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* ==================== COMPONENTS ==================== */
        .btn {
            padding: 10px 16px; border-radius: var(--radius); border: var(--border-width) solid transparent;
            font-weight: 600; cursor: pointer; transition: 0.2s; font-size: 13px;
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
            font-family: var(--font-main); box-shadow: var(--shadow);
        }
        .btn-primary { background: var(--accent); color: white; border-color: var(--accent); }
        .btn-primary:hover { opacity: 0.9; filter: brightness(110%); }
        .btn-secondary { background: var(--bg-card); color: var(--text-main); border-color: var(--border); }
        .btn-secondary:hover { border-color: var(--text-muted); }
        .btn-icon { padding: 8px; border-radius: 50%; width: 36px; height: 36px; }
        .btn-danger { color: var(--danger); background: rgba(239, 68, 68, 0.1); }
        .btn-danger:hover { background: rgba(239, 68, 68, 0.2); }

        .input-group {
            background: var(--bg-card); padding: 15px; border-radius: var(--radius);
            display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px;
            border: var(--border-width) solid var(--border); align-items: center; box-shadow: var(--shadow);
        }
        .main-input { background: transparent; border: none; color: var(--text-main); padding: 10px; flex: 1; min-width: 200px; outline: none; font-size: 16px; font-family: var(--font-main); }
        .date-input, .select-input { background: var(--bg-body); border: var(--border-width) solid var(--border); color: var(--text-main); padding: 10px 12px; border-radius: var(--radius); outline: none; font-size: 14px; font-family: var(--font-main); }

        /* Task Cards */
        .task-list { display: flex; flex-direction: column; gap: 12px; padding-bottom: 80px; }
        .task-card {
            background: var(--bg-card); border-radius: var(--radius); padding: 16px;
            border: var(--border-width) solid var(--border); border-left: 4px solid var(--border);
            transition: all 0.2s; box-shadow: var(--shadow); position: relative;
        }
        .task-header { display: flex; align-items: flex-start; gap: 15px; }
        .checkbox { appearance: none; width: 24px; height: 24px; border: 2px solid var(--text-muted); border-radius: 6px; cursor: pointer; flex-shrink: 0; margin-top: 2px; position: relative; }
        .checkbox:checked { background: var(--accent); border-color: var(--accent); }
        .checkbox:checked::after { content: '✓'; position: absolute; color: white; font-size: 14px; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        .task-content { flex: 1; min-width: 0; }
        .task-title { font-size: 15px; margin-bottom: 5px; line-height: 1.4; color: var(--text-main); word-wrap: break-word; }
        .task-meta { display: flex; flex-wrap: wrap; gap: 10px; font-size: 12px; color: var(--text-muted); align-items: center; }
        .tag { padding: 2px 8px; border-radius: 10px; background: rgba(32, 128, 132, 0.15); color: var(--accent); font-size: 11px; font-weight: 600; white-space: nowrap;}
        
        .priority-high { border-left-color: var(--danger); }
        .priority-medium { border-left-color: var(--warning); }
        .priority-low { border-left-color: var(--success); }

        .subtasks { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border); display: flex; flex-direction: column; gap: 10px; }
        .subtask-row { display: flex; align-items: center; gap: 12px; font-size: 14px; padding-left: 5px; }

        .suggestions { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 10px; margin-bottom: 10px; }
        .suggestion-chip { padding: 6px 14px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 20px; font-size: 12px; cursor: pointer; white-space: nowrap; transition: 0.2s; display: flex; align-items: center; gap: 8px; color: var(--text-muted); }
        
        /* Calendar */
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; margin-top: 20px; }
        .cal-day-header { text-align: center; font-size: 11px; color: var(--text-muted); padding-bottom: 5px; }
        .cal-cell { background: var(--bg-card); border-radius: var(--radius); min-height: 80px; padding: 5px; border: 1px solid var(--border); position: relative; overflow: hidden; cursor: pointer; transition: 0.2s; }
        .cal-cell:hover { border-color: var(--accent); }
        .cal-cell.today { border-color: var(--accent); background: rgba(32, 128, 132, 0.05); }
        .cal-cell.selected { border: 2px solid var(--text-main); }
        .cal-date { font-size: 11px; font-weight: bold; margin-bottom: 3px; color: var(--text-main); }
        .cal-task-dot { width: 100%; margin-bottom: 2px; padding: 2px; border-radius: 3px; font-size: 9px; background: var(--bg-input); color: var(--text-main); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cal-task-dot.done { text-decoration: line-through; opacity: 0.5; }
        
        /* Mobile List for Calendar */
        .cal-mobile-list { margin-top: 20px; padding: 15px; background: var(--bg-card); border-radius: var(--radius); border: 1px solid var(--border); display: none; }
        
        /* Focus Timer */
        .timer-container { text-align:center; max-width:500px; margin:0 auto; }
        .timer-circle { 
            width: 240px; height: 240px; border-radius: 50%; border: 8px solid var(--bg-card); 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            margin: 20px auto; position: relative; 
            background: radial-gradient(circle, var(--bg-sidebar) 0%, var(--bg-body) 100%); 
            box-shadow: var(--shadow); color: var(--text-main); transition: 0.3s; 
        }
        .timer-time { font-size: 48px; font-weight: 700; line-height: 1; }
        .timer-label { font-size: 14px; text-transform: uppercase; color: var(--text-muted); margin-top: 5px; letter-spacing: 1px;}
        
        /* Visual Glows */
        .timer-active.focus-mode { 
            border-color: var(--accent); 
            box-shadow: 0 0 40px rgba(32, 128, 132, 0.5), inset 0 0 15px rgba(32, 128, 132, 0.2); 
        }
        .timer-active.break-mode { 
            border-color: var(--success); 
            box-shadow: 0 0 40px rgba(16, 185, 129, 0.5), inset 0 0 15px rgba(16, 185, 129, 0.2); 
        }
        .timer-active.paused { 
            border-color: var(--warning);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
            animation: pulse 2s infinite; 
            opacity: 0.9; 
        }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        .idle-tracker {
            margin-top: 30px; padding: 15px; border-top: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }

        /* Leaderboard */
        .leaderboard-table { width: 100%; border-collapse: collapse; margin-top: 10px; min-width: 300px; }
        .leaderboard-table th { text-align: left; padding: 10px; color: var(--text-muted); font-size: 12px; border-bottom: 1px solid var(--border); }
        .leaderboard-table td { padding: 12px 10px; border-bottom: 1px solid var(--border); font-size: 14px; }
        .rank-badge { width: 24px; height: 24px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 11px; font-weight: bold; margin-right: 10px; }
        .rank-1 { background: #fbbf24; color: #78350f; } .rank-2 { background: #94a3b8; color: #0f172a; } .rank-3 { background: #b45309; color: #fffbeb; }

        /* WhatsApp/Telegram Style Chat Features */
        .typing-indicator {
            padding: 8px 15px;
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
        }
        
        .typing-dots {
            display: flex;
            gap: 4px;
        }
        
        .typing-dots span {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-muted);
            animation: typing 1.4s infinite;
        }
        
        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                opacity: 0.3;
                transform: translateY(0);
            }
            30% {
                opacity: 1;
                transform: translateY(-10px);
            }
        }
        
        .input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 25px;
            padding: 5px 10px;
            flex: 1;
        }
        
        .input-wrapper input {
            flex: 1;
            border: none;
            background: transparent;
            color: var(--text-main);
            font-size: 14px;
            outline: none;
        }
        
        .emoji-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .emoji-btn:hover {
            color: var(--accent);
            background: rgba(32, 128, 132, 0.1);
        }
        
        .emoji-picker {
            position: absolute;
            bottom: 60px;
            left: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
            display: none;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            box-shadow: var(--shadow);
            z-index: 1000;
        }
        
        .emoji-picker button {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .emoji-picker button:hover {
            background: var(--bg-hover);
            transform: scale(1.1);
        }
        
        .message-reactions {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        
        .reaction-btn {
            background: none;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .reaction-btn:hover {
            background: var(--bg-hover);
            transform: scale(1.05);
        }
        
        .reaction-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        
        .message-status {
            font-size: 10px;
            opacity: 0.6;
            margin-left: 5px;
        }
        
        .message-status.delivered {
            color: var(--text-muted);
        }
        
        .message-status.read {
            color: var(--success);
        }
        
        .message-status.sending {
            color: var(--warning);
        }
        
        .message-status.failed {
            color: var(--danger);
        }
        
        /* Enhanced Message Bubbles */
        .chat-msg {
            max-width: 70%;
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
            animation: messageSlideIn 0.3s ease-out;
        }
        
        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .chat-msg.me {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--accent), var(--accent-hover));
            color: white;
            border-bottom-right-radius: 4px;
        }
        
        .chat-msg.them {
            align-self: flex-start;
            background: var(--bg-card);
            color: var(--text-main);
            border-bottom-left-radius: 4px;
        }
        
        .chat-msg .msg-content {
            margin: 0;
            line-height: 1.4;
        }
        
        .chat-msg .msg-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .chat-msg .msg-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 4px;
            font-size: 10px;
            opacity: 0.7;
        }
        
        .chat-msg .msg-actions {
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .chat-msg:hover .msg-actions {
            opacity: 1;
        }
        
        /* Online Status Indicators */
        .user-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        
        .user-status-dot.online {
            background: var(--success);
            animation: pulse 2s infinite;
        }
        
        .user-status-dot.idle {
            background: var(--warning);
        }
        
        .user-status-dot.away {
            background: var(--text-muted);
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(32, 128, 132, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(32, 128, 132, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(32, 128, 132, 0);
            }
        }

        /* Notes & Chat */
        .note-card { background: var(--bg-card); border: var(--border-width) solid var(--border); border-radius: var(--radius); padding: 20px; margin-bottom: 15px; box-shadow: var(--shadow); display: flex; flex-direction: column; }
        .note-header-actions { display: flex; justify-content: flex-end; gap: 8px; margin-bottom: 10px; }
        .note-action-btn { background: var(--bg-body); border: 1px solid var(--border); color: var(--text-muted); width: 30px; height: 30px; border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; }
        .note-action-btn:hover { color: var(--accent); border-color: var(--accent); background: var(--bg-hover); }
        .note-content { font-family: 'Playfair Display', serif; font-size: 18px; line-height: 1.6; color: var(--text-main); white-space: pre-wrap; flex: 1; }
        .note-date { font-family: var(--font-main); font-size: 11px; color: var(--text-muted); margin-top: 15px; text-align: right; border-top: 1px solid var(--border); padding-top: 10px; }
        
        .chat-layout { display: flex; height: 500px; background: var(--bg-body); border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden; margin-top: 20px; }
        .chat-main { flex: 1; display: flex; flex-direction: column; border-right: 1px solid var(--border); }
        .chat-messages { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        .chat-input-area { padding: 10px; background: var(--bg-card); border-top: 1px solid var(--border); display: flex; gap: 10px; }
        .chat-sidebar-panel { width: 200px; background: var(--bg-sidebar); padding: 10px; overflow-y: auto; display: none; }
        @media(min-width: 768px) { .chat-sidebar-panel { display: block; } }
        .chat-msg { max-width: 80%; padding: 8px 12px; border-radius: 12px; font-size: 13px; line-height: 1.4; word-wrap: break-word; }
        .chat-msg.them { background: var(--bg-card); align-self: flex-start; border-bottom-left-radius: 0; border: 1px solid var(--border); }
        .chat-msg.me { background: var(--accent); color: white; align-self: flex-end; border-bottom-right-radius: 0; }

        @media (max-width: 768px) {
            .sidebar { position: fixed; top: 0; left: 0; bottom: 0; transform: translateX(-100%); box-shadow: 5px 0 15px rgba(0,0,0,0.5); }
            .sidebar.open { transform: translateX(0); }
            .menu-btn { display: block; }
            .view-container { padding: 15px; }
            .input-group { flex-direction: column; align-items: stretch; }
            .date-input, .select-input, .btn { width: 100%; }
            .timer-circle { width: 200px; height: 200px; border-width: 6px; }
            .timer-time { font-size: 40px; }
            .cal-cell { min-height: 50px; }
            .cal-task-dot { display: none; }
            .cal-mobile-list { display: block; }
            .chat-layout { height: 100%; flex-direction: column; }
            .chat-sidebar-panel { width: 100%; height: 100px; border-bottom: 1px solid var(--border); display: block; }
        }
        
        /* New Focus Stats */
        .focus-stat-container { display:flex; align-items:center; justify-content:space-between; width:100%; gap:20px; flex-wrap:wrap;}
        .focus-stat-box { flex:1; min-width:200px; background:var(--bg-body); border-radius:10px; padding:15px; border:1px solid var(--border); display:flex; flex-direction:column; gap:5px;}
        .progress-bar { width:100%; height:8px; background:var(--bg-body); border-radius:4px; overflow:hidden; margin-top:5px; border:1px solid var(--border); }
        .progress-fill { height:100%; background:var(--accent); border-radius:4px; width:0%; transition: width 0.5s ease; }

        /* Task Focus Row */
        .focus-task-row { display:flex; justify-content:space-between; align-items:center; font-size:12px; padding:6px 0; border-bottom:1px solid var(--border); }
        .focus-task-row:last-child { border-bottom:none; }
        .focus-task-name { color:var(--text-main); font-weight:500; flex: 1; }
        .focus-task-time { color:var(--text-muted); font-family:monospace; margin-right: 10px; }
        .focus-task-actions { display: flex; gap: 5px; opacity: 0.6; transition: 0.2s; }
        .focus-task-row:hover .focus-task-actions { opacity: 1; }
        .focus-icon-btn { cursor: pointer; color: var(--text-muted); font-size: 11px; padding: 2px; }
        .focus-icon-btn:hover { color: var(--accent); }
        
        /* Community Layout */
        .community-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            height: 600px;
        }
        
        .leaderboard-section, .chat-section {
            background: var(--bg-card);
            border: var(--border-width) solid var(--border);
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
        }

        /* ALARM MODAL */
        #alarmModal { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:2000; display:none; align-items:center; justify-content:center; backdrop-filter: blur(10px); }
        .alarm-content { background: var(--bg-card); padding: 40px; border-radius: 20px; text-align: center; border: 2px solid var(--accent); box-shadow: 0 0 50px rgba(32, 128, 132, 0.4); animation: pulseAlarm 1s infinite; max-width: 90%; }
        @keyframes pulseAlarm { 0% { transform: scale(1); box-shadow: 0 0 30px rgba(32, 128, 132, 0.4); } 50% { transform: scale(1.02); box-shadow: 0 0 60px rgba(32, 128, 132, 0.7); } 100% { transform: scale(1); box-shadow: 0 0 30px rgba(32, 128, 132, 0.4); } }
    </style>
    <style id="dynamic-theme-style"></style>
</head>
<body>

    <div class="sidebar-overlay" id="sidebarOverlay" onclick="app.toggleSidebar()"></div>

    <div id="alarmModal">
        <div class="alarm-content">
            <i class="fas fa-bell" style="font-size: 60px; color: var(--accent); margin-bottom: 20px;"></i>
            <h1 style="color: var(--text-main); margin-bottom: 10px;">Time is Up!</h1>
            <p style="color: var(--text-muted); margin-bottom: 30px; font-size: 16px;">Good job. Take a breath.</p>
            <button class="btn btn-primary" style="padding: 15px 40px; font-size: 18px;" onclick="focusMode.stopAlarmUI()">Stop Alarm</button>
        </div>
    </div>

    <aside class="sidebar" id="sidebar">
        <div class="logo">
            <i class="fas fa-bolt"></i> TaskPro 9.0
            <button class="btn btn-icon" style="margin-left:auto; background:transparent; display:none;" onclick="app.toggleSidebar()" id="closeSidebarBtn"><i class="fas fa-times"></i></button>
        </div>
        
        <nav>
            <button class="nav-link active" onclick="app.switchTab('dashboard')"><i class="fas fa-chart-pie"></i> Dashboard</button>
            <button class="nav-link" onclick="app.switchTab('tasks')">
                <i class="fas fa-tasks"></i> My Tasks
                <span id="badge" style="margin-left:auto; background:var(--accent); padding:2px 8px; border-radius:10px; font-size:10px; color: white;">0</span>
            </button>
            <button class="nav-link" onclick="app.switchTab('habits')"><i class="fas fa-fire"></i> Habits</button>
            <button class="nav-link" onclick="app.switchTab('notes')"><i class="fas fa-sticky-note"></i> My Notes</button>
            <button class="nav-link" onclick="app.switchTab('calendar')"><i class="far fa-calendar-alt"></i> Calendar</button>
            <button class="nav-link" onclick="app.switchTab('focus')"><i class="fas fa-stopwatch"></i> Pomodoro & Idle</button>
            <button class="nav-link" onclick="app.switchTab('community')"><i class="fas fa-users"></i> Community</button>
        </nav>

        <div style="margin-top: auto;">
            <button class="nav-link" onclick="app.saveLifetime(true)">
                <i class="fas fa-save"></i> Force Save
            </button>
            <button class="nav-link" onclick="app.backupData()">
                <i class="fas fa-download"></i> Checkpoint
            </button>
            <button class="nav-link" onclick="app.resetAllData()" style="color:var(--danger);">
                <i class="fas fa-trash-alt"></i> Reset All Data
            </button>

            <button class="nav-link" onclick="document.getElementById('importInput').click()">
                <i class="fas fa-upload"></i> Restore
            </button>
            <input type="file" id="importInput" style="display:none" onchange="app.restoreData(this)">
            <div class="nav-link" style="cursor: default; opacity: 0.7; font-size:12px;">
                <i class="fas fa-cloud"></i> <span id="syncText">Offline</span>
            </div>
            <button class="btn btn-secondary" style="width:100%; margin-top:10px;" id="authBtn" onclick="app.toggleAuth()">Sign In</button>
        </div>
    </aside>

    <main class="main">
        <header class="header">
            <div style="display:flex; align-items:center; gap:10px;">
                <button class="menu-btn" onclick="app.toggleSidebar()"><i class="fas fa-bars"></i></button>
                <h2 id="pageTitle" style="color:var(--text-main); font-size: 18px;">Dashboard</h2>
            </div>

            <div style="display:flex; align-items:center;">
                <div class="weather-widget">
                    <div id="clockDisplay" style="margin-bottom:2px;">--:--</div>
                    <div class="weather-info" id="weatherDisplay">
                        <i class="fas fa-cloud"></i> <span>--°C</span>
                    </div>
                </div>

                <div class="header-actions">
                    <button class="btn btn-primary" style="font-size:11px; padding: 8px 12px;" onclick="app.generateRandomDesign()" title="Remix UI">
                        <i class="fas fa-magic"></i>
                    </button>
                    <button class="icon-btn-header" onclick="app.toggleTheme()"><i class="fas fa-moon" id="themeIcon"></i></button>
                    <div style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--warning);" id="syncDot"></div>
                    </div>
                </div>
            </div>
        </header>

        <div id="dashboard" class="view-container active">
            <div style="display:flex; gap:10px; margin-bottom:20px; overflow-x:auto;">
                <select id="dashFilterTime" class="select-input" style="width:auto;" onchange="app.renderDashboardCharts()">
                    <option value="all">All Time</option>
                    <option value="daily">Today</option>
                    <option value="weekly">This Week</option>
                    <option value="monthly">This Month</option>
                    <option value="yearly">This Year</option>
                </select>
                <select id="dashFilterTag" class="select-input" style="width:auto;" onchange="app.renderDashboardCharts()">
                    <option value="all">All Tags</option>
                </select>
            </div>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; margin-bottom: 30px;">
                <div class="task-card" style="text-align:center; padding: 20px 10px;">
                    <div style="font-size:28px; font-weight:700; color:var(--accent);" id="dashTotal">0</div>
                    <div style="color:var(--text-muted); font-size:11px; margin-top:5px;">TOTAL (INC. SUBS)</div>
                </div>
                <div class="task-card" style="text-align:center; padding: 20px 10px;">
                    <div style="font-size:28px; font-weight:700; color:var(--success);" id="dashDone">0</div>
                    <div style="color:var(--text-muted); font-size:11px; margin-top:5px;">COMPLETED</div>
                </div>
                <div class="task-card" style="text-align:center; padding: 20px 10px;">
                    <div style="font-size:28px; font-weight:700; color:var(--warning);" id="dashPending">0</div>
                    <div style="color:var(--text-muted); font-size:11px; margin-top:5px;">PENDING</div>
                </div>
                <div class="task-card" style="text-align:center; padding: 20px 10px;">
                    <div style="font-size:28px; font-weight:700; color:var(--streak-fire); display:flex; align-items:center; justify-content:center; gap:8px;">
                        <span id="streakCount">0</span>
                        <i class="fas fa-fire" id="streakIcon" style="font-size:20px; opacity:0.3; transition:0.3s;"></i>
                    </div>
                    <div style="color:var(--text-muted); font-size:11px; margin-top:5px;">DAILY STREAK</div>
                </div>
                <div class="task-card" style="text-align:center; padding: 20px 10px; border-left-color: var(--streak-target);">
                    <div style="font-size:28px; font-weight:700; color:var(--streak-target); display:flex; align-items:center; justify-content:center; gap:8px;">
                        <span id="subStreakCount">0</span>
                        <i class="fas fa-crosshairs" style="font-size:18px;"></i>
                    </div>
                    <div style="margin-top:5px; padding:0 10px;">
                        <select id="subStreakSelect" class="select-input" style="width:100%; font-size:11px; padding:5px; background: var(--bg-body);" onchange="app.updateSubStreak()">
                            <option value="">Select Task...</option>
                        </select>
                    </div>
                    <div style="font-size:9px; color:var(--text-muted); margin-top:5px;">TASK SPECIFIC STREAK</div>
                </div>
            </div>

            <div class="task-card" style="margin-bottom:20px; border-left-color:var(--accent);">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <h3 style="color:var(--text-main); font-size:16px;">Focus Goal & Analytics</h3>
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span style="font-size:12px; color:var(--text-muted);">Daily Goal:</span>
                        <input type="number" id="dailyGoalInput" class="select-input" style="width:60px; padding:4px;" value="3" onchange="app.setDailyGoal(this.value)">
                        <span style="font-size:12px; color:var(--text-muted);">hrs</span>
                    </div>
                </div>
                <div class="focus-stat-container">
                    <div class="focus-stat-box">
                        <div style="display:flex; align-items:center; justify-content:space-between; font-size:11px; color:var(--text-muted); text-transform:uppercase;">
                            <span>Time Focused (<span id="focusTimeLabel">Today</span>)</span>
                            <button class="btn btn-icon btn-danger" style="width:20px;height:20px;padding:0;font-size:10px; opacity:0.7;" onclick="app.resetFocusData()" title="Reset All Focus History"><i class="fas fa-trash"></i></button>
                        </div>
                        <div style="font-size:24px; font-weight:700; color:var(--text-main); margin-top:5px;" id="focusTimeDisplay">0h 0m</div>
                    </div>
                    <div class="focus-stat-box" style="flex:2;">
                         <div style="display:flex; justify-content:space-between; font-size:11px; color:var(--text-muted); margin-bottom:2px;">
                            <span>Goal Progress</span>
                            <span id="goalPercentDisplay">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="goalProgressBar"></div>
                        </div>
                        <div style="font-size:10px; color:var(--text-muted); margin-top:5px;">Target: <span id="goalTargetDisplay">3h</span></div>
                    </div>
                </div>
                
                <div style="margin-top:15px; border-top:1px solid var(--border); padding-top:15px;">
                    <h4 style="font-size:12px; color:var(--text-muted); margin-bottom:10px; text-transform:uppercase;">Top Focused Tasks</h4>
                    <div id="taskFocusList" style="max-height:150px; overflow-y:auto; padding-right:5px;">
                        <div style="font-size:12px; color:var(--text-muted); font-style:italic;">No specific task data yet.</div>
                    </div>
                </div>
                
                <div style="margin-top:15px; border-top:1px solid var(--border); padding-top:15px;">
                    <h4 style="font-size:12px; color:var(--text-muted); margin-bottom:10px; text-transform:uppercase;">Focus Timeline</h4>
                    <div id="focusTimeline" style="max-height:200px; overflow-y:auto; padding-right:5px;">
                        <div style="font-size:12px; color:var(--text-muted); font-style:italic;">No focus sessions yet.</div>
                    </div>
                </div>
            </div>

            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap:20px;">
                <div class="task-card">
                    <h3 style="margin-bottom:15px; color:var(--text-main); font-size:16px;">Productivity Trend</h3>
                    <div style="height: 250px; position: relative;"><canvas id="mainChart"></canvas></div>
                </div>
                <div class="task-card">
                    <h3 style="margin-bottom:15px; color:var(--text-main); font-size:16px;">Hashtag Analysis</h3>
                    <div style="height: 250px; position: relative;"><canvas id="tagChart"></canvas></div>
                </div>
            </div>
        </div>

        <div id="tasks" class="view-container">
            <div class="suggestions" id="suggestionsBox"></div>
            <div class="input-group">
                <input type="hidden" id="editTaskId">
                <input type="text" id="taskInput" class="main-input" placeholder="Add a task... (Use #tag)">
                <select id="hashtagSelect" class="select-input" style="width: auto; margin-left: 5px;" onchange="app.addSelectedHashtag()">
                    <option value=""># Tags</option>
                </select>
                <input type="date" id="dateInput" class="date-input">
                <select id="prioInput" class="select-input" style="width: auto;">
                    <option value="medium">Medium</option>
                    <option value="high">High</option>
                    <option value="low">Low</option>
                </select>
                <button class="btn btn-primary" id="addUpdateBtn" onclick="app.handleTaskSubmit()"><i class="fas fa-plus"></i> Add</button>
                <button class="btn btn-secondary" id="cancelEditBtn" style="display:none;" onclick="app.cancelEdit()">Cancel</button>
            </div>
            <div class="input-group">
                <textarea id="taskDescInput" class="main-input" placeholder="Task description (optional)..." style="resize:vertical; min-height:60px; width:100%;"></textarea>
            </div>
            <div style="margin-bottom:15px; display:flex; gap:10px;">
                <button class="btn btn-secondary" onclick="app.setTaskFilter('active')" id="filterActive">Active</button>
                <button class="btn btn-secondary" onclick="app.setTaskFilter('overdue')" id="filterOverdue">Overdue</button>
                <button class="btn btn-secondary" onclick="app.setTaskFilter('completed')" id="filterCompleted">Completed</button>
            </div>
            <div id="taskList" class="task-list"></div>
        </div>

        <div id="notes" class="view-container">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                <div>
                    <h2 style="color:var(--text-main);">My Notes & Quotes</h2>
                    <p style="color:var(--text-muted); font-size:13px;">Online Storage. Your thoughts, safe in the cloud.</p>
                </div>
                <div style="font-size:30px; color:var(--accent); opacity:0.5;"><i class="fas fa-feather-alt"></i></div>
            </div>
            <div class="input-group" style="align-items:flex-start;">
                <textarea id="noteInput" class="main-input" rows="3" style="resize:vertical; min-height:80px;" placeholder="Write a quote, thought, or memo..."></textarea>
                <button class="btn btn-primary" style="height:fit-content;" onclick="app.addNote()">Save Note</button>
            </div>
            <div id="notesList" style="display: flex; flex-direction: column; gap: 15px;"></div>
        </div>

        <div id="habits" class="view-container">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                <div>
                    <h2 style="color:var(--text-main);">Habit Challenges</h2>
                    <p style="color:var(--text-muted); font-size:13px;">Build lasting habits with 7 & 21 day challenges.</p>
                </div>
                <button class="btn btn-primary" onclick="app.showAddHabitModal()"><i class="fas fa-plus"></i> Add Habit</button>
            </div>
            
            <div id="habitsList" class="task-list"></div>
        </div>

        <div id="calendar" class="view-container">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h2 id="calMonthYear" style="color:var(--text-main); font-size:18px;"></h2>
                <div style="display:flex; gap:5px;">
                    <button class="btn btn-secondary btn-icon" onclick="app.changeMonth(-1)"><i class="fas fa-chevron-left"></i></button>
                    <button class="btn btn-secondary btn-icon" onclick="app.changeMonth(1)"><i class="fas fa-chevron-right"></i></button>
                </div>
            </div>
            <div class="calendar-grid" id="calGrid"></div>
            <div class="cal-mobile-list" id="calMobileView">
                <h4 style="margin-bottom:10px; color:var(--text-muted);" id="calSelectedDate">Select a date</h4>
                <div id="calSelectedTasks"></div>
            </div>
        </div>

        <div id="focus" class="view-container">
            <div class="timer-container">
                <h2 style="color:var(--text-main); margin-bottom: 20px;">Pomodoro & Idle Tracker</h2>
                
                <div style="margin-bottom: 20px;">
                    <label style="display:block; font-size:12px; color:var(--text-muted); margin-bottom:5px;">Link to Task (Optional)</label>
                    <select id="focusTaskSelect" class="select-input" style="width:100%; max-width:300px;">
                        <option value="">-- No specific task --</option>
                    </select>
                </div>

                <div style="display:flex; justify-content:center; gap:10px; margin-bottom:20px; flex-wrap:wrap;">
                    <div style="display:flex; flex-direction:column; gap:5px; align-items:flex-start;">
                        <span style="font-size:11px; color:var(--text-muted);">Focus (min)</span>
                        <input type="number" id="focusDuration" class="select-input" value="25" style="width:80px; text-align:center;">
                    </div>
                    <div style="display:flex; flex-direction:column; gap:5px; align-items:flex-start;">
                        <span style="font-size:11px; color:var(--text-muted);">Break (min)</span>
                        <input type="number" id="breakDuration" class="select-input" value="5" style="width:80px; text-align:center;">
                    </div>
                    <div style="display:flex; flex-direction:column; gap:5px; align-items:flex-start;">
                        <span style="font-size:11px; color:var(--text-muted);">Soundscape</span>
                        <select id="soundSelect" class="select-input" style="width:140px;" onchange="focusMode.changeSound(this.value)">
                            <option value="none">Silent</option>
                            <option value="beats">Deep Focus (Beats)</option>
                            <option value="wind">Pink Noise</option>
                            <option value="white">White Noise</option>
                            <option value="brown">Brown Noise</option>
                            <option value="rain">Heavy Rain</option>
                            <option value="forest">Forest (Birds)</option>
                            <option value="night">Night (Crickets)</option>
                            <option value="ocean">Ocean Waves</option>
                            <option value="fan">Fan</option>
                        </select>
                    </div>
                </div>

                <div class="timer-circle" id="timerCircle">
                    <span id="timerDisplay" class="timer-time">25:00</span>
                    <span id="timerLabel" class="timer-label">Ready</span>
                </div>

                <div style="display:flex; justify-content:center; gap:10px; margin-bottom:30px; flex-wrap: wrap;">
                    <button class="btn btn-primary" id="btnStartFocus" onclick="focusMode.start('focus')" style="min-width:110px;">Start Focus</button>
                    <button class="btn btn-secondary" id="btnStartBreak" onclick="focusMode.start('break')" style="border-color:var(--success); color:var(--success); min-width:110px;">Start Break</button>
                    
                    <button class="btn btn-secondary" id="btnPause" onclick="focusMode.togglePause()" style="display:none; background:var(--bg-body); color:var(--warning); border-color:var(--warning); min-width:80px;">
                        <i class="fas fa-pause"></i> Pause
                    </button>
                    
                    <button class="btn btn-secondary btn-danger" onclick="focusMode.stop()">Stop</button>
                </div>

                <div class="idle-tracker">
                    <div style="text-align:left;">
                        <h4 style="color:var(--text-main); font-size:15px;"><i class="fas fa-hourglass-half"></i> Idle Time</h4>
                        <p style="color:var(--text-muted); font-size:11px;">Time spent online without timer running</p>
                    </div>
                    <div style="font-family:'Roboto Mono', monospace; font-size:24px; color:var(--warning);" id="idleDisplay">
                        00:00:00
                    </div>
                </div>
            </div>
        </div>

        <div id="community" class="view-container">
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:30px;">
                <div class="community-grid">
                    <div class="leaderboard-section">
                        <div class="section-header">
                            <h3><i class="fas fa-trophy"></i> Leaderboard</h3>
                            <button class="btn btn-secondary btn-sm" onclick="app.syncLeaderboard()">
                                <i class="fas fa-sync"></i> Refresh
                            </button>
                        </div>
                        <div id="commBoard">
                            <div class="leaderboard-stats">
                                <div class="stat-item">
                                    <span class="stat-number" id="totalPlayers">0</span>
                                    <span class="stat-label">Players</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-number" id="topScore">0</span>
                                    <span class="stat-label">Top Score</span>
                                </div>
                            </div>
                            <table class="leaderboard-table">
                                <thead>
                                    <tr>
                                        <th>Rank</th>
                                        <th>Username</th>
                                        <th>Score</th>
                                    </tr>
                                </thead>
                                <tbody id="leaderboardBody">
                                    <tr>
                                        <td colspan="3" style="text-align:center; color:var(--text-muted); padding:20px;">
                                            Loading leaderboard...
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="chat-section">
                        <div class="section-header">
                            <h3><i class="fas fa-comments"></i> Group Chat</h3>
                            <div style="display:flex; align-items:center; gap:10px;">
                                <div style="width:8px; height:8px; border-radius:50%; background:var(--success);" id="chatStatus"></div>
                                <span style="font-size:12px; color:var(--text-muted);" id="onlineCount">0 online</span>
                            </div>
                        </div>
                        <div class="chat-layout">
                            <div class="chat-main">
                                <div class="chat-messages" id="chatMsgs"></div>
                                <div class="typing-indicator" id="typingIndicator" style="display:none;">
                                    <div class="typing-dots">
                                        <span></span>
                                        <span></span>
                                        <span></span>
                                    </div>
                                    <span id="typingText">Someone is typing...</span>
                                </div>
                                <div class="emoji-picker" id="emojiPicker">
                                    <button onclick="app.addEmoji('😀')">😀</button>
                                    <button onclick="app.addEmoji('😂')">😂</button>
                                    <button onclick="app.addEmoji('❤️')">❤️</button>
                                    <button onclick="app.addEmoji('👍')">👍</button>
                                    <button onclick="app.addEmoji('🎉')">🎉</button>
                                    <button onclick="app.addEmoji('🔥')">🔥</button>
                                    <button onclick="app.addEmoji('😊')">😊</button>
                                    <button onclick="app.addEmoji('😎')">😎</button>
                                    <button onclick="app.addEmoji('🤔')">🤔</button>
                                    <button onclick="app.addEmoji('😅')">😅</button>
                                    <button onclick="app.addEmoji('🙏')">🙏</button>
                                    <button onclick="app.addEmoji('💪')">💪</button>
                                    <button onclick="app.addEmoji('🚀')">🚀</button>
                                    <button onclick="app.addEmoji('💯')">💯</button>
                                    <button onclick="app.addEmoji('🎯')">🎯</button>
                                </div>
                                <div class="chat-input-area">
                                    <div class="input-wrapper">
                                        <input type="text" id="chatInput" class="main-input" placeholder="Type a message..." autocomplete="off" oninput="app.handleTyping()" onblur="app.stopTyping()" onkeypress="if(event.keyCode===13) { event.preventDefault(); event.stopPropagation(); app.sendMessage(); return false; }">
                                        <button type="button" class="emoji-btn" onclick="app.toggleEmojiPicker()" title="Emoji">
                                            <i class="fas fa-smile"></i>
                                        </button>
                                        <button type="button" class="btn btn-primary" onclick="app.sendMessage()">
                                            <i class="fas fa-paper-plane"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="chat-sidebar-panel">
                                <div style="font-size:12px; font-weight:bold; color:var(--text-muted); margin-bottom:10px;">ONLINE USERS</div>
                                <div id="chatParticipants"></div>
                            </div>
                        </div>
                    </div>
                </div>
        </div>
    </main>

    <div style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1000; display:none; align-items:center; justify-content:center; backdrop-filter: blur(5px);" id="authModal">
        <div style="background:var(--bg-sidebar); padding:30px; border-radius:16px; width:90%; max-width:400px; border:1px solid var(--border); text-align:center; position:relative;">
            <h2 style="margin-bottom:20px; color:var(--text-main);">Cloud Sync</h2>
            <form onsubmit="event.preventDefault(); app.login();">
                <input type="email" id="authEmail" class="main-input" style="border:1px solid var(--border); background:var(--bg-body); width:100%; margin-bottom:10px; border-radius:8px;" placeholder="Email" autocomplete="username">
                <input type="password" id="authPass" class="main-input" style="border:1px solid var(--border); background:var(--bg-body); width:100%; margin-bottom:20px; border-radius:8px;" placeholder="Password" autocomplete="current-password">
                
                <div style="margin-bottom: 20px; text-align: right;">
                    <a href="#" onclick="app.forgotPassword()" style="color: var(--accent); font-size: 13px; text-decoration: none;">Forgot Password?</a>
                </div>

                <div style="display:flex; gap:10px;">
                    <button type="submit" class="btn btn-primary" style="flex:1">Login</button>
                    <button type="button" class="btn btn-secondary" style="flex:1" onclick="app.register()">Sign Up</button>
                </div>
            </form>
            <button class="btn btn-icon" style="position:absolute; top:10px; right:10px; width:auto; height:auto; color:var(--text-muted);" onclick="document.getElementById('authModal').style.display='none'">✕</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, updateDoc, deleteDoc, doc, onSnapshot, query, where, writeBatch, orderBy, limit, getDocs, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCoCFw0hezldX3t33AYa1ytddYMuQCWliM",
            authDomain: "daily-todo-1e4ad.firebaseapp.com",
            projectId: "daily-todo-1e4ad",
            storageBucket: "daily-todo-1e4ad.firebasestorage.app",
            messagingSenderId: "629797690976",
            appId: "1:629797690976:web:fda66df1691eb920e12d05"
        };
        // 1. Register the Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(() => console.log("Service Worker Registered"))
                .catch(err => console.log("SW Registration Failed", err));
        }

        // 2. Request Notification Permission (For Alarms)
        if ("Notification" in window && Notification.permission !== "granted") {
            Notification.requestPermission();
        }
        const appInit = initializeApp(firebaseConfig);
        const auth = getAuth(appInit);
        const db = getFirestore(appInit);

        const state = {
            user: null,
            tasks: [],
            notes: [],
            focusLogs: JSON.parse(localStorage.getItem('focusLogs')) || [],
            history: JSON.parse(localStorage.getItem('taskHistory')) || ["Meeting", "Workout", "Study"],
            currentDate: new Date(),
            charts: {},
            customDesign: localStorage.getItem('customDesignCSS') || null,
            taskFilter: 'active',
            weather: { temp: '--', condition: 'Unknown' },
            subStreakTask: localStorage.getItem('subStreakTask') || '',
            idleSeconds: parseInt(localStorage.getItem('localIdleSeconds')) || 0,
            dailyGoal: parseInt(localStorage.getItem('dailyGoal')) || 3,
            habits: [] // Add habits to state
        };

        window.app = {
            init: () => {
                app.updateClock();
                setInterval(app.updateClock, 1000 * 60);
                app.fetchWeather();
                document.getElementById('dateInput').valueAsDate = new Date();
                document.getElementById('dailyGoalInput').value = state.dailyGoal;
                
                if(state.customDesign) document.getElementById('dynamic-theme-style').textContent = state.customDesign;
                
                if(!state.user) {
                    state.notes = JSON.parse(localStorage.getItem('local_notes')) || [];
                    app.renderNotes();
                }

                window.addEventListener('storage', (e) => {
                    if (e.key === 'local_tasks' && !state.user) {
                        state.tasks = JSON.parse(e.newValue || "[]");
                        renderTasks();
                        if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
                    }
                });

                if("Notification" in window && Notification.permission !== 'granted') {
                    Notification.requestPermission();
                }
            },

            updateClock: () => {
                const now = new Date();
                const time = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                document.getElementById('clockDisplay').textContent = time;
            },

            fetchWeather: () => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(async (pos) => {
                        try {
                            const { latitude, longitude } = pos.coords;
                            const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);
                            const data = await res.json();
                            const temp = Math.round(data.current_weather.temperature);
                            document.getElementById('weatherDisplay').innerHTML = `<i class="fas fa-cloud-sun"></i> <span>${temp}${data.current_weather_units.temperature}</span>`;
                        } catch (e) { console.error("Weather Error", e); }
                    }, () => {
                        document.getElementById('weatherDisplay').innerHTML = `<span>Loc. Denied</span>`;
                    });
                }
            },

            generateRandomDesign: () => {
                const hue = Math.floor(Math.random() * 360);
                const sat = Math.floor(Math.random() * 40) + 20;
                const lit = Math.floor(Math.random() * 15) + 5;
                const fonts = ["'Inter', sans-serif", "'Playfair Display', serif", "'Roboto Mono', monospace", "'Comic Neue', cursive"];
                const font = fonts[Math.floor(Math.random() * fonts.length)];
                const css = `:root { --bg-body: hsl(${hue}, ${sat}%, ${lit}%); --bg-sidebar: hsl(${hue}, ${sat}%, ${lit + 5}%); --bg-card: hsl(${hue}, ${sat}%, ${lit + 10}%); --bg-input: hsl(${hue}, ${sat}%, ${lit + 5}%); --accent: hsl(${(hue + 180) % 360}, 70%, 50%); --font-main: ${font}; }`;
                document.getElementById('dynamic-theme-style').textContent = css;
                localStorage.setItem('customDesignCSS', css);
                state.customDesign = css;
            },

            toggleTheme: () => {
                const html = document.documentElement;
                const icon = document.getElementById('themeIcon');
                if (html.getAttribute('data-theme') === 'dark') {
                    html.setAttribute('data-theme', 'light');
                    icon.className = 'fas fa-sun';
                    document.getElementById('dynamic-theme-style').textContent = "";
                } else {
                    html.setAttribute('data-theme', 'dark');
                    icon.className = 'fas fa-moon';
                    if(state.customDesign) document.getElementById('dynamic-theme-style').textContent = state.customDesign;
                }
            },

            saveLifetime: async (showNotification = false) => {
                localStorage.setItem('local_tasks', JSON.stringify(state.tasks));
                localStorage.setItem('local_notes', JSON.stringify(state.notes));
                localStorage.setItem('localIdleSeconds', state.idleSeconds);
                localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));
                if (showNotification) {
                    if(state.user) { 
                        alert("Cloud Sync is active. Your data is saved automatically as you type."); 
                    } else { 
                        alert("Local data secured. Sign in to enable Cloud Sync."); 
                    }
                }
            },

            resetAllData: async () => {
                if(!confirm("⚠️ DANGER ZONE ⚠️\n\nThis will permanently DELETE ALL tasks, history, notes, and statistics.\n\nAre you sure?")) return;
                if(!confirm("Last chance: This cannot be undone. Confirm full data wipe?")) return;

                state.tasks = [];
                state.notes = [];
                state.focusLogs = [];
                state.history = ["Meeting", "Workout", "Study"]; 
                state.charts = {};
                state.idleSeconds = 0;
                localStorage.removeItem('local_tasks');
                localStorage.removeItem('local_notes');
                localStorage.removeItem('focusLogs');
                localStorage.setItem('taskHistory', JSON.stringify(state.history));
                localStorage.setItem('localIdleSeconds', 0);

                if(state.user) {
                    try {
                        const batch = writeBatch(db);
                        const qTasks = query(collection(db, 'tasks'), where('uid', '==', state.user.uid));
                        const snapTasks = await getDocs(qTasks);
                        snapTasks.docs.forEach(doc => { batch.delete(doc.ref); });
                        const qNotes = query(collection(db, 'notes'), where('uid', '==', state.user.uid));
                        const snapNotes = await getDocs(qNotes);
                        snapNotes.docs.forEach(doc => { batch.delete(doc.ref); });
                        await batch.commit();
                        await setDoc(doc(db, 'leaderboard', state.user.uid), {
                            username: state.user.email.split('@')[0],
                            score: 0,
                            lastActive: Date.now()
                        });
                        await setDoc(doc(db, 'timers', state.user.uid), {
                            status: 'idle', idleSeconds: 0, updatedAt: Date.now()
                        });
                        alert("Cloud data wiped successfully.");
                    } catch (e) { alert("Error wiping cloud data: " + e.message); }
                } else { alert("Local data wiped successfully."); }

                renderTasks();
                app.renderNotes();
                renderSuggestions();
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            backupData: () => {
                const data = { meta: { version: "5.0", date: new Date().toISOString() }, tasks: state.tasks, notes: state.notes, history: state.history };
                const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "TaskPro_Checkpoint_" + Date.now() + ".json";
                a.click();
            },

            restoreData: (input) => {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if(data.tasks && Array.isArray(data.tasks)) {
                            if(state.user) {
                                alert("Restoring to cloud... please wait.");
                                const batch = writeBatch(db);
                                data.tasks.forEach(t => {
                                    const { id, ...taskData } = t;
                                    const newDocRef = doc(collection(db, 'tasks'));
                                    batch.set(newDocRef, { ...taskData, uid: state.user.uid });
                                });
                                if(data.notes) {
                                    data.notes.forEach(n => {
                                        const { id, ...noteData } = n;
                                        const newNoteRef = doc(collection(db, 'notes'));
                                        batch.set(newNoteRef, { ...noteData, uid: state.user.uid });
                                    });
                                }
                                await batch.commit();
                                alert("Cloud restore successful!");
                            } else {
                                state.tasks = [...state.tasks, ...data.tasks];
                                if(data.notes) state.notes = [...state.notes, ...data.notes];
                                app.saveLifetime(true);
                                renderTasks();
                                app.renderNotes();
                            }
                        }
                    } catch(err) { alert("Invalid File Format"); console.error(err); }
                };
                reader.readAsText(file);
            },

            toggleSidebar: () => {
                document.getElementById('sidebar').classList.toggle('open');
                const overlay = document.getElementById('sidebarOverlay');
                overlay.style.display = overlay.style.display === 'block' ? 'none' : 'block';
            },

            switchTab: (id) => {
                document.querySelectorAll('.view-container').forEach(el => el.classList.remove('active'));
                document.querySelectorAll('.nav-link').forEach(el => el.classList.remove('active'));
                document.getElementById(id).classList.add('active');
                event.currentTarget.classList.add('active');
                document.getElementById('pageTitle').textContent = (id === 'notes' ? "My Notes" : id.charAt(0).toUpperCase() + id.slice(1));
                
                if(window.innerWidth <= 768) app.toggleSidebar();
                if(id === 'dashboard') app.renderDashboardCharts();
                if(id === 'calendar') renderCalendar();
                if(id === 'community') app.loadCommunity();
                if(id === 'focus') app.loadFocusTasks();
                if(id === 'notes') app.renderNotes();
            },

            toggleAuth: () => { 
                if(state.user) {
                    // Clean up before signing out
                    app.cleanup();
                    signOut(auth); 
                } else {
                    document.getElementById('authModal').style.display = 'flex'; 
                }
            },
            
            cleanup: () => {
                // Clean up all listeners and timeouts
                if(app.statusInterval) {
                    clearInterval(app.statusInterval);
                    app.statusInterval = null;
                }
                if(app.chatUnsubscribe) {
                    app.chatUnsubscribe();
                    app.chatUnsubscribe = null;
                }
                if(app.typingTimeout) {
                    clearTimeout(app.typingTimeout);
                    app.typingTimeout = null;
                }
                if(focusMode.timerInterval) {
                    clearInterval(focusMode.timerInterval);
                    focusMode.timerInterval = null;
                }
                if(focusMode.alarmTimeout) {
                    clearTimeout(focusMode.alarmTimeout);
                    focusMode.alarmTimeout = null;
                }
                AudioEngine.stopBackground();
                AudioEngine.stopAlarm();
                console.log('Cleanup completed');
            },
            
            login: async () => {
                try { await signInWithEmailAndPassword(auth, document.getElementById('authEmail').value, document.getElementById('authPass').value); document.getElementById('authModal').style.display='none'; } catch(e){alert(e.message);}
            },
            
            register: async () => {
                try { await createUserWithEmailAndPassword(auth, document.getElementById('authEmail').value, document.getElementById('authPass').value); document.getElementById('authModal').style.display='none'; } catch(e){alert(e.message);}
            },

            forgotPassword: async () => {
                const email = document.getElementById('authEmail').value;
                if(!email) { alert("Please enter your email address in the box first."); return; }
                try { await sendPasswordResetEmail(auth, email); alert("Password reset email sent! Check your inbox."); } catch(e) { alert("Error: " + e.message); }
            },
            
            loadHashtagSelect: () => {
                const select = document.getElementById('hashtagSelect');
                const currentValue = select.value;
                
                // Get hashtags from completed tasks only
                const completedTasks = state.tasks.filter(t => t.completed);
                const completedTags = [...new Set(completedTasks.flatMap(t => t.tags || []))];
                
                // Clear and populate select
                select.innerHTML = '<option value=""># Tags</option>';
                
                completedTags.forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag;
                    option.textContent = '#' + tag;
                    if(tag === currentValue) option.selected = true;
                    select.appendChild(option);
                });
            },
            
            addSelectedHashtag: () => {
                const select = document.getElementById('hashtagSelect');
                const taskInput = document.getElementById('taskInput');
                const selectedTag = select.value;
                
                if(!selectedTag) return;
                
                const currentText = taskInput.value.trim();
                const hashtag = '#' + selectedTag;
                
                // Check if hashtag already exists
                if(!currentText.includes(hashtag)) {
                    taskInput.value = currentText + (currentText ? ' ' : '') + hashtag;
                }
                
                // Reset select
                select.value = '';
                
                // Focus back to input
                taskInput.focus();
            },

            setTaskFilter: (filter) => {
                state.taskFilter = filter;
                document.getElementById('filterActive').className = filter === 'active' ? 'btn btn-primary' : 'btn btn-secondary';
                document.getElementById('filterOverdue').className = filter === 'overdue' ? 'btn btn-primary' : 'btn btn-secondary';
                document.getElementById('filterCompleted').className = filter === 'completed' ? 'btn btn-primary' : 'btn btn-secondary';
                renderTasks();
            },

            handleTaskSubmit: async () => {
                const id = document.getElementById('editTaskId').value;
                if(id) await app.updateTask(id); else await app.addTask();
            },

            addTask: async (title = null) => {
                const input = document.getElementById('taskInput');
                const descInput = document.getElementById('taskDescInput');
                const text = title || input.value.trim();
                if(!text) return;

                if(!state.history.includes(text)) {
                    state.history.unshift(text);
                    if(state.history.length > 8) state.history.pop();
                    localStorage.setItem('taskHistory', JSON.stringify(state.history));
                    renderSuggestions();
                }

                const newTask = {
                    text,
                    completed: false,
                    date: document.getElementById('dateInput').value,
                    priority: document.getElementById('prioInput').value,
                    tags: (text.match(/#\w+/g) || []).map(t => t.replace('#','')),
                    subtasks: [],
                    description: descInput.value.trim() || '',
                    createdAt: Date.now()
                };

                if(state.user) {
                    try {
                        const docRef = await addDoc(collection(db, 'tasks'), { ...newTask, uid: state.user.uid });
                        // Update local state with Firebase ID
                        newTask.id = docRef.id;
                        state.tasks.push(newTask);
                        console.log('Task added successfully with ID:', docRef.id);
                    } catch(e) {
                        console.error('Error adding task to Firebase:', e);
                        alert('Could not save task to cloud. Please try again.');
                        return;
                    }
                } else {
                    newTask.id = 'local_' + Date.now();
                    state.tasks.push(newTask);
                    app.saveLifetime(false);
                    renderTasks();
                }
                if(!title) {
                    input.value = '';
                    descInput.value = '';
                }
            },

            startEdit: (id) => {
                const task = state.tasks.find(t => t.id === id);
                if(!task) return;
                document.getElementById('taskInput').value = task.text;
                document.getElementById('taskDescInput').value = task.description || '';
                document.getElementById('dateInput').value = task.date;
                document.getElementById('prioInput').value = task.priority;
                document.getElementById('editTaskId').value = task.id;
                const btn = document.getElementById('addUpdateBtn');
                btn.innerHTML = 'Update';
                btn.classList.replace('btn-primary', 'btn-secondary');
                document.getElementById('cancelEditBtn').style.display = 'inline-block';
            },

            updateTask: async (id) => {
                const text = document.getElementById('taskInput').value;
                const date = document.getElementById('dateInput').value;
                const priority = document.getElementById('prioInput').value;
                const tags = (text.match(/#\w+/g) || []).map(t => t.replace('#',''));
                const description = document.getElementById('taskDescInput').value.trim() || '';
                
                const oldTask = state.tasks.find(t => t.id === id);
                const subtasks = oldTask ? (oldTask.subtasks || []) : [];

                if(state.user) {
                    try {
                        await updateDoc(doc(db, 'tasks', id), { text, date, priority, tags, description, subtasks });
                        // Update local state
                        const idx = state.tasks.findIndex(t => t.id === id);
                        if(idx !== -1) {
                            state.tasks[idx] = { ...state.tasks[idx], text, date, priority, tags, description, subtasks };
                        }
                        console.log('Task updated successfully');
                    } catch(e) {
                        console.error('Error updating task:', e);
                        alert('Could not update task. Please try again.');
                        return;
                    }
                } else {
                    const idx = state.tasks.findIndex(t => t.id === id);
                    if(idx !== -1) { 
                        state.tasks[idx] = { ...state.tasks[idx], text, date, priority, tags, description }; 
                        app.saveLifetime(false); 
                        renderTasks(); 
                    }
                }
                app.cancelEdit();
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            cancelEdit: () => {
                document.getElementById('taskInput').value = '';
                document.getElementById('taskDescInput').value = '';
                document.getElementById('dateInput').valueAsDate = new Date();
                document.getElementById('prioInput').value = 'medium';
                document.getElementById('editTaskId').value = '';
                const btn = document.getElementById('addUpdateBtn');
                btn.innerHTML = '<i class="fas fa-plus"></i> Add';
                btn.classList.replace('btn-secondary', 'btn-primary');
                document.getElementById('cancelEditBtn').style.display = 'none';
            },

            toggleTask: async (id) => {
                const task = state.tasks.find(t => t.id === id);
                const newVal = !task.completed;
                
                if(state.user) {
                    try {
                        await updateDoc(doc(db, 'tasks', id), { completed: newVal });
                        // Update local state
                        task.completed = newVal;
                        console.log('Task status updated successfully');
                        
                        // Update leaderboard when task is completed
                        if(newVal) {
                            app.syncLeaderboard();
                        }
                    } catch(e) {
                        console.error('Error toggling task:', e);
                        alert('Could not update task status. Please try again.');
                        return;
                    }
                } else { 
                    task.completed = newVal; 
                    app.saveLifetime(false); 
                    renderTasks();
                    
                    // Update leaderboard when task is completed
                    if(newVal) {
                        app.syncLeaderboard();
                    }
                }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            deleteTask: async (id) => {
                if(!confirm("Permanently delete?")) return;
                
                if(state.user) {
                    try {
                        await deleteDoc(doc(db, 'tasks', id));
                        // Update local state
                        state.tasks = state.tasks.filter(t => t.id !== id);
                        console.log('Task deleted successfully');
                    } catch(e) {
                        console.error('Error deleting task:', e);
                        alert('Could not delete task. Please try again.');
                        return;
                    }
                } else { 
                    state.tasks = state.tasks.filter(t => t.id !== id); 
                    app.saveLifetime(false); 
                    renderTasks(); 
                }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            addSubtask: async (parentId) => {
                const input = document.getElementById(`sub-input-${parentId}`);
                if(!input.value.trim()) return;
                const task = state.tasks.find(t => t.id === parentId);
                const newSub = { 
                    id: Date.now(), 
                    text: input.value.trim(), 
                    description: '',
                    completed: false 
                };
                const subtasks = [...(task.subtasks||[]), newSub];
                if(state.user) await updateDoc(doc(db, 'tasks', parentId), { subtasks });
                else { 
                    task.subtasks = subtasks; 
                    app.saveLifetime(false); 
                    renderTasks(); 
                }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },
            
            addSubtaskWithDesc: async (parentId) => {
                const input = document.getElementById(`sub-input-${parentId}`);
                const text = input.value.trim();
                if(!text) return;
                
                const description = prompt('Enter subtask description (optional):');
                const task = state.tasks.find(t => t.id === parentId);
                const newSub = { 
                    id: Date.now(), 
                    text: text, 
                    description: description || '',
                    completed: false 
                };
                const subtasks = [...(task.subtasks||[]), newSub];
                if(state.user) await updateDoc(doc(db, 'tasks', parentId), { subtasks });
                else { 
                    task.subtasks = subtasks; 
                    app.saveLifetime(false); 
                    renderTasks(); 
                }
                
                input.value = '';
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },
            
            toggleSubtask: async (parentId, subId) => {
                const task = state.tasks.find(t => t.id === parentId);
                const subtasks = task.subtasks.map(s => s.id == subId ? {...s, completed: !s.completed} : s);
                if(state.user) await updateDoc(doc(db, 'tasks', parentId), { subtasks });
                else { task.subtasks = subtasks; app.saveLifetime(false); renderTasks(); }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            deleteSubtask: async (parentId, subId) => {
                const task = state.tasks.find(t => t.id === parentId);
                const subtasks = task.subtasks.filter(s => s.id != subId);
                if(state.user) await updateDoc(doc(db, 'tasks', parentId), { subtasks });
                else { task.subtasks = subtasks; app.saveLifetime(false); renderTasks(); }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },
            
            editTaskDescription: (taskId) => {
                const task = state.tasks.find(t => t.id === taskId);
                if(!task) return;
                
                const newDescription = prompt('Edit task description:', task.description || '');
                if(newDescription === null) return; // User cancelled
                
                task.description = newDescription;
                
                if(state.user) {
                    updateDoc(doc(db, 'tasks', taskId), { description: newDescription });
                } else {
                    app.saveLifetime(false);
                    renderTasks();
                }
            },
            
            editSubtaskDescription: (parentId, subId) => {
                const task = state.tasks.find(t => t.id === parentId);
                if(!task) return;
                
                const subtask = task.subtasks.find(s => s.id === subId);
                if(!subtask) return;
                
                const newDescription = prompt('Edit subtask description:', subtask.description || '');
                if(newDescription === null) return; // User cancelled
                
                subtask.description = newDescription;
                
                if(state.user) {
                    updateDoc(doc(db, 'tasks', parentId), { subtasks: task.subtasks });
                } else {
                    app.saveLifetime(false);
                    renderTasks();
                }
            },

            addNote: async () => {
                const input = document.getElementById('noteInput');
                const content = input.value.trim();
                if(!content) return;
                
                const newNote = { content, createdAt: Date.now() };

                if(state.user) {
                    try {
                        const docRef = await addDoc(collection(db, 'notes'), { ...newNote, uid: state.user.uid });
                        // Update local state with Firebase ID
                        newNote.id = docRef.id;
                        state.notes.unshift(newNote);
                        console.log('Note added successfully with ID:', docRef.id);
                        input.value = '';
                    } catch(e) {
                        console.error('Error adding note to Firebase:', e);
                        alert('Could not save note to cloud. Please try again.');
                    }
                } else {
                    newNote.id = 'local_note_' + Date.now();
                    state.notes.unshift(newNote);
                    localStorage.setItem('local_notes', JSON.stringify(state.notes));
                    app.renderNotes();
                    input.value = '';
                }
            },

            deleteNote: async (id) => {
                if(!confirm("Permanently delete this note?")) return;
                
                if(state.user) {
                    try {
                        await deleteDoc(doc(db, 'notes', id));
                        // Update local state
                        state.notes = state.notes.filter(n => n.id !== id);
                        console.log('Note deleted successfully');
                    } catch(e) {
                        console.error('Error deleting note:', e);
                        alert('Could not delete note. Please try again.');
                        return;
                    }
                } else {
                    state.notes = state.notes.filter(n => n.id !== id);
                    localStorage.setItem('local_notes', JSON.stringify(state.notes));
                    app.renderNotes();
                }
            },

            enableEditNote: (id) => {
                const note = state.notes.find(n => n.id === id);
                if(!note) return;
                const card = document.getElementById(`note-card-${id}`);
                const contentDiv = card.querySelector('.note-content');
                const currentText = note.content;
                contentDiv.innerHTML = `<textarea id="edit-note-input-${id}" class="main-input" style="width:100%; min-height:100px; background:var(--bg-body); border:1px solid var(--accent); resize:vertical;">${currentText}</textarea>`;
                const actionsDiv = card.querySelector('.note-header-actions');
                actionsDiv.innerHTML = `<button class="btn btn-primary" style="padding: 5px 10px; font-size: 12px;" onclick="app.saveEditedNote('${id}')">Save</button><button class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="app.renderNotes()">Cancel</button>`;
            },

            saveEditedNote: async (id) => {
                const input = document.getElementById(`edit-note-input-${id}`);
                const newContent = input.value.trim();
                if(!newContent) return;

                if(state.user) {
                    try {
                        await updateDoc(doc(db, 'notes', id), { content: newContent });
                        // Update local state
                        const idx = state.notes.findIndex(n => n.id === id);
                        if(idx !== -1) {
                            state.notes[idx].content = newContent;
                        }
                        console.log('Note updated successfully');
                    } catch(e) {
                        console.error('Error updating note:', e);
                        alert('Could not update note. Please try again.');
                        return;
                    }
                } else {
                    const idx = state.notes.findIndex(n => n.id === id);
                    if(idx !== -1) {
                        state.notes[idx].content = newContent;
                        localStorage.setItem('local_notes', JSON.stringify(state.notes));
                        app.renderNotes();
                    }
                }
            },

            renderNotes: () => {
                const list = document.getElementById('notesList');
                if(!list) return;
                const sortedNotes = [...state.notes].sort((a,b) => b.createdAt - a.createdAt);
                if(sortedNotes.length === 0) {
                    list.innerHTML = `<div style="text-align:center; color:var(--text-muted); margin-top:30px;"><i class="fas fa-pencil-alt" style="font-size:24px; margin-bottom:10px;"></i><br>No notes yet. Save your first thought!</div>`;
                    return;
                }
                list.innerHTML = sortedNotes.map(note => {
                    const dateObj = new Date(note.createdAt);
                    const dateStr = dateObj.toLocaleDateString() + ' ' + dateObj.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                    return `
                    <div class="note-card" id="note-card-${note.id}">
                        <div class="note-header-actions">
                            <button class="note-action-btn" onclick="app.enableEditNote('${note.id}')" title="Edit"><i class="fas fa-pencil"></i></button>
                            <button class="note-action-btn delete-btn" onclick="app.deleteNote('${note.id}')" title="Delete"><i class="fas fa-trash"></i></button>
                        </div>
                        <div class="note-content">${note.content}</div>
                        <div class="note-date">${dateStr}</div>
                    </div>`;
                }).join('');
            },

            changeMonth: (offset) => {
                state.currentDate.setMonth(state.currentDate.getMonth() + offset);
                renderCalendar();
            },
            selectDate: (dateStr) => {
                document.getElementById('calSelectedDate').textContent = new Date(dateStr).toDateString();
                const tasks = state.tasks.filter(t => t.date === dateStr);
                const html = tasks.length ? tasks.map(t => `<div style="padding:10px; background:var(--bg-body); margin-bottom:5px; border-radius:5px; border-left:3px solid var(--accent);">${t.text} ${t.completed?'(Done)':''}</div>`).join('') : '<div style="color:var(--text-muted)">No tasks.</div>';
                document.getElementById('calSelectedTasks').innerHTML = html;
                document.querySelectorAll('.cal-cell').forEach(c => c.classList.remove('selected'));
                const cell = document.querySelector(`.cal-cell[data-date="${dateStr}"]`);
                if(cell) cell.classList.add('selected');
            },

            syncLeaderboard: async () => {
                if (!state.user) return;
                const completedCount = state.tasks.filter(t => t.completed).length;
                const score = completedCount * 10;
                const username = state.user.email.split('@')[0];
                try {
                    await setDoc(doc(db, 'leaderboard', state.user.uid), { username: username, score: score, lastActive: Date.now() });
                } catch (e) { console.error("Leaderboard Sync Error:", e); }
            },

            loadLeaderboard: async () => {
                const boardBody = document.getElementById('leaderboardBody');
                boardBody.innerHTML = `<tr><td colspan="3" style="text-align:center; padding:20px;">Loading live scores...</td></tr>`;

                try {
                    const q = query(collection(db, 'leaderboard'), orderBy('score', 'desc'), limit(20));
                    const snapshot = await getDocs(q);
                    
                    let html = '';
                    let rank = 1;
                    let totalPlayers = 0;
                    let topScore = 0;

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const isMe = state.user && doc.id === state.user.uid;
                        
                        if(rank === 1) topScore = data.score;
                        totalPlayers++;
                        
                        let rankDisplay = `<span style="opacity:0.5">#${rank}</span>`;
                        if (rank === 1) rankDisplay = `<span class="rank-badge rank-1">1</span>`;
                        if (rank === 2) rankDisplay = `<span class="rank-badge rank-2">2</span>`;
                        if (rank === 3) rankDisplay = `<span class="rank-badge rank-3">3</span>`;
                        const rowStyle = isMe ? `background: rgba(32, 128, 132, 0.15); font-weight:bold; border-left: 3px solid var(--accent);` : ``;
                        html += `<tr style="${rowStyle}"><td>${rankDisplay}</td><td>${data.username} ${isMe ? '(You)' : ''}</td><td style="text-align:right; font-family:monospace; font-size:15px;">${data.score}</td></tr>`;
                        rank++;
                    });

                    if (snapshot.empty) {
                        html = `<tr><td colspan="3" style="text-align:center; color:var(--text-muted); padding:20px;">No players yet.</td></tr>`;
                    }
                    
                    boardBody.innerHTML = html;
                    
                    // Update stats
                    document.getElementById('totalPlayers').textContent = totalPlayers;
                    document.getElementById('topScore').textContent = topScore;
                    
                } catch (e) {
                    console.error(e);
                    boardBody.innerHTML = `<tr><td colspan="3" style="color:var(--danger); text-align:center;">Could not load leaderboard.<br>Sign in required.</td></tr>`;
                }
            },
            
            loadCommunity: async () => {
                if(!state.user) return;
                
                // Load leaderboard
                app.loadLeaderboard();
                
                // CRITICAL: Set user as ONLINE when in community section
                app.setUserStatus('online');
                app.updateUserStatusList();
                
                // Auto-start chat - no need to join anymore
                app.loadCommunityChat();
                app.setupChatListener();
                
                // Start status tracking for chat
                app.startStatusTracking();
                
                // Force online status update
                setTimeout(() => {
                    app.setUserStatus('online');
                    app.updateUserStatusList();
                }, 500);
            },

            // Community Chat Functions
            joinGroupChat: () => {
                if(!state.user) {
                    alert('Please sign in to join the group chat.');
                    app.toggleAuth();
                    return;
                }
                
                document.getElementById('commBoard').style.display = 'none';
                document.getElementById('groupChat').style.display = 'flex';
                app.loadCommunityChat();
                app.setupChatListener();
                
                // Start status tracking when joining chat
                app.startStatusTracking();
                app.updateUserStatusList();
            },
            
            leaveGroup: () => {
                document.getElementById('commBoard').style.display = 'block';
                document.getElementById('groupChat').style.display = 'none';
                
                // Stop status tracking when leaving chat
                app.stopStatusTracking();
                
                // Clean up chat listener
                if(app.chatUnsubscribe) {
                    app.chatUnsubscribe();
                    app.chatUnsubscribe = null;
                }
                
                // Clean up typing timeout
                if(app.typingTimeout) {
                    clearTimeout(app.typingTimeout);
                    app.typingTimeout = null;
                }
            },
            
            loadCommunityChat: async () => {
                const msgsEl = document.getElementById('chatMsgs');
                if(msgsEl) {
                    msgsEl.innerHTML = '<div style="text-align:center; color:var(--text-muted); padding:20px;">Loading chat...</div>';
                    
                    try {
                        const q = query(collection(db, 'community_chat'), orderBy('timestamp', 'desc'), limit(50));
                        const snapshot = await getDocs(q);
                        
                        const messages = snapshot.docs.map(d => ({id: d.id, ...d.data()})).reverse();
                        
                        if(messages.length === 0) {
                            // Try loading local messages if no Firebase messages
                            app.loadLocalChatMessages();
                        } else {
                            console.log('=== DEBUG INFO ===');
                            console.log('Total messages to render:', messages.length);
                            console.log('Current user UID:', state.user?.uid);
                            console.log('Current user email:', state.user?.email);
                            
                            // Check first message details
                            if(messages.length > 0) {
                                const firstMsg = messages[0];
                                console.log('First message:', {
                                    id: firstMsg.id,
                                    uid: firstMsg.uid,
                                    username: firstMsg.username,
                                    timestamp: firstMsg.timestamp,
                                    text: firstMsg.text
                                });
                                console.log('UID comparison:', {
                                    msgUid: firstMsg.uid,
                                    userUid: state.user?.uid,
                                    match: firstMsg.uid === state.user?.uid
                                });
                            }
                            
                            // Use WhatsApp-style rendering
                            msgsEl.innerHTML = messages.map(msg => app.renderChatMessage(msg, false)).join('');
                            msgsEl.scrollTop = msgsEl.scrollHeight;
                            
                            console.log('=== END DEBUG INFO ===');
                        }
                    } catch(e) {
                        console.error('Load chat error:', e);
                        console.log('Firebase chat failed, loading local messages');
                        
                        // Load local messages as fallback
                        app.loadLocalChatMessages();
                        
                        // Show notification about local mode
                        const notification = document.createElement('div');
                        notification.style.cssText = 'position:fixed; top:20px; right:20px; background:var(--warning); color:white; padding:10px 15px; border-radius:8px; z-index:1000; font-size:12px;';
                        notification.textContent = 'Chat running in local mode (Firebase permissions restricted)';
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 5000);
                    }
                }
            },
            
            setupChatListener: () => {
                if(!state.user) return;
                
                if(app.chatUnsubscribe) {
                    app.chatUnsubscribe();
                }
                
                const q = query(collection(db, 'community_chat'), orderBy('timestamp', 'desc'), limit(50));
                app.chatUnsubscribe = onSnapshot(q, (snapshot) => {
                    const msgsEl = document.getElementById('chatMsgs');
                    if(!msgsEl) return;
                    
                    const messages = snapshot.docs.map(d => ({id: d.id, ...d.data()})).reverse();
                    
                    if(messages.length === 0) {
                        msgsEl.innerHTML = '<div style="text-align:center; color:var(--text-muted); padding:20px;">No messages yet. Start the conversation!</div>';
                    } else {
                        // Use WhatsApp-style rendering for real-time updates
                        msgsEl.innerHTML = messages.map(msg => app.renderChatMessage(msg, false)).join('');
                        msgsEl.scrollTop = msgsEl.scrollHeight;
                    }
                    
                    // Update online count and user status list
                    app.updateUserStatusList();
                    
                    // Update participants list (legacy - now handled by updateUserStatusList)
                    const participantsEl = document.getElementById('chatParticipants');
                    if(participantsEl) {
                        const userCounts = {};
                        messages.forEach(msg => {
                            if(!userCounts[msg.username]) {
                                userCounts[msg.username] = { uid: msg.uid, lastMessage: msg.timestamp };
                            } else if(msg.timestamp > userCounts[msg.username].lastMessage) {
                                userCounts[msg.username].lastMessage = msg.timestamp;
                            }
                        });
                        
                        const sortedUsers = Object.entries(userCounts)
                            .sort((a,b) => b[1].lastMessage - a[1].lastMessage)
                            .slice(0, 10);
                            
                        // Only update if status list is not already showing
                        if(!participantsEl.innerHTML.includes('fa-circle') && !participantsEl.innerHTML.includes('fa-moon')) {
                            participantsEl.innerHTML = sortedUsers.map(([username, data]) => {
                                const isMe = data.uid === state.user.uid;
                                return `
                                <div style="padding:5px; font-size:11px; color:var(--text-muted); ${isMe ? 'font-weight:bold;color:var(--accent);' : ''}">
                                    ${username} ${isMe ? '(You)' : ''}
                                </div>`;
                            }).join('');
                        }
                    }
                });
            },
            
            sendMessage: async () => {
                if(!state.user) {
                    alert('Please sign in to send messages.');
                    return;
                }
                
                const input = document.getElementById('chatInput');
                const text = input.value.trim();
                if(!text) return;
                
                // Disable input temporarily
                input.disabled = true;
                input.placeholder = 'Sending...';
                
                try {
                    console.log('Sending message:', { uid: state.user.uid, username: state.user.email.split('@')[0], text: text });
                    
                    await addDoc(collection(db, 'community_chat'), {
                        uid: state.user.uid,
                        username: state.user.email.split('@')[0],
                        text: text,
                        timestamp: Date.now()
                    });
                    
                    console.log('Message sent successfully');
                    input.value = '';
                    
                    // Update user status to online when sending message
                    app.setUserStatus('online');
                    
                } catch(e) {
                    console.error('Send message error:', e);
                    console.error('Error details:', e.code, e.message);
                    
                    // Firebase permission denied - use local fallback
                    if(e.code === 'permission-denied') {
                        console.log('Firebase permission denied, using local chat fallback');
                        
                        // Add message to local chat storage
                        const localMessage = {
                            id: 'local_' + Date.now(),
                            uid: state.user.uid,
                            username: state.user.email.split('@')[0],
                            text: text,
                            timestamp: Date.now(),
                            isLocal: true
                        };
                        
                        // Get existing local messages or create new array
                        let localMessages = JSON.parse(localStorage.getItem('local_chat_messages') || '[]');
                        localMessages.push(localMessage);
                        
                        // Keep only last 50 messages
                        if(localMessages.length > 50) {
                            localMessages = localMessages.slice(-50);
                        }
                        
                        // Save to localStorage
                        localStorage.setItem('local_chat_messages', JSON.stringify(localMessages));
                        
                        // Add message to chat display
                        app.addLocalMessageToChat(localMessage);
                        
                        console.log('Message sent locally');
                        input.value = '';
                        
                        // Show friendly message
                        const notification = document.createElement('div');
                        notification.style.cssText = 'position:fixed; top:20px; right:20px; background:var(--warning); color:white; padding:10px 15px; border-radius:8px; z-index:1000; font-size:12px;';
                        notification.textContent = 'Message saved locally (Firebase permissions restricted)';
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 3000);
                        
                    } else if(e.code === 'unavailable') {
                        alert('Chat service is temporarily unavailable. Please try again.');
                    } else {
                        alert('Could not send message. Error: ' + e.message);
                    }
                } finally {
                    // Re-enable input
                    input.disabled = false;
                    input.placeholder = 'Type a message...';
                    input.focus();
                }
            },
            
            addLocalMessageToChat: (message) => {
                const msgsEl = document.getElementById('chatMsgs');
                if(!msgsEl) return;
                
                // Remove "No messages yet" message if it exists
                if(msgsEl.innerHTML.includes('No messages yet')) {
                    msgsEl.innerHTML = '';
                }
                
                const isMe = message.uid === state.user.uid;
                const time = new Date(message.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                const messageHtml = `
                <div class="chat-msg ${isMe ? 'me' : 'them'}">
                    <div style="font-size:10px; opacity:0.7; margin-bottom:2px;">${message.username} • ${time} ${message.isLocal ? '(local)' : ''}</div>
                    <div>${message.text}</div>
                </div>`;
                
                msgsEl.insertAdjacentHTML('beforeend', messageHtml);
                msgsEl.scrollTop = msgsEl.scrollHeight;
            },
            
            loadLocalChatMessages: () => {
                const msgsEl = document.getElementById('chatMsgs');
                if(!msgsEl) return;
                
                const localMessages = JSON.parse(localStorage.getItem('local_chat_messages') || '[]');
                
                if(localMessages.length === 0) {
                    msgsEl.innerHTML = '<div style="text-align:center; color:var(--text-muted); padding:20px;">No messages yet. Start the conversation!</div>';
                } else {
                    msgsEl.innerHTML = localMessages.map(msg => {
                        const isMe = msg.uid === state.user.uid;
                        const time = new Date(msg.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                        console.log('Rendering local message:', { id: msg.id, isMe, username: msg.username });
                        return `
                        <div class="chat-msg ${isMe ? 'me' : 'them'}" id="msg-${msg.id}">
                            <div style="font-size:10px; opacity:0.7; margin-bottom:2px; display:flex; justify-content:space-between; align-items:center;">
                                <span>${msg.username} • ${time} ${msg.isLocal ? '(local)' : ''}</span>
                                ${isMe ? `
                                <div style="display:flex; gap:8px; background:rgba(255,255,255,0.1); padding:2px 6px; border-radius:4px;">
                                    <button onclick="app.editChatMessage('${msg.id}', '${msg.text.replace(/'/g, "\\'")}')" style="background:none; border:none; color:var(--text-muted); cursor:pointer; font-size:11px; padding:2px 4px; border-radius:2px;" title="Edit message">
                                        <i class="fas fa-pencil"></i> Edit
                                    </button>
                                    <button onclick="app.deleteChatMessage('${msg.id}')" style="background:none; border:none; color:var(--danger); cursor:pointer; font-size:11px; padding:2px 4px; border-radius:2px;" title="Delete message">
                                        <i class="fas fa-trash"></i> Delete
                                    </button>
                                </div>` : ''}
                            </div>
                            <div class="msg-content">${msg.text}</div>
                        </div>`;
                    }).join('');
                    msgsEl.scrollTop = msgsEl.scrollHeight;
                }
            },
            
            // WhatsApp/Telegram Style Chat Functions
            handleTyping: () => {
                if(!state.user) return;
                
                // Broadcast typing indicator to Firebase
                const typingData = {
                    uid: state.user.uid,
                    username: state.user.email.split('@')[0],
                    typing: true,
                    timestamp: Date.now()
                };
                
                // Update typing status in Firebase
                const typingRef = doc(db, 'typing_status', state.user.uid);
                setDoc(typingRef, typingData, { merge: true });
                
                // Stop typing after 3 seconds
                clearTimeout(app.typingTimeout);
                app.typingTimeout = setTimeout(() => {
                    app.stopTyping();
                }, 3000);
            },
            
            stopTyping: () => {
                if(!state.user) return;
                
                // Remove typing indicator from Firebase
                const typingRef = doc(db, 'typing_status', state.user.uid);
                setDoc(typingRef, { typing: false }, { merge: true });
                
                clearTimeout(app.typingTimeout);
            },
            
            toggleEmojiPicker: () => {
                const picker = document.getElementById('emojiPicker');
                if(picker.style.display === 'grid') {
                    picker.style.display = 'none';
                } else {
                    picker.style.display = 'grid';
                }
            },
            
            addEmoji: (emoji) => {
                const input = document.getElementById('chatInput');
                input.value += emoji;
                input.focus();
                app.toggleEmojiPicker();
            },
            
            // Enhanced Message Rendering with WhatsApp/Telegram Style
            renderChatMessage: (msg, isLocal = false) => {
                const isMe = msg.uid === state.user.uid;
                const time = new Date(msg.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                
                const statusHtml = isLocal ? '<span class="message-status">(local)</span>' : '';
                const editedHtml = msg.edited ? '<span style="color:var(--text-muted); font-size:9px; font-style:italic; margin-left:5px;">edited</span>' : '';
                
                return `
                <div class="chat-msg ${isMe ? 'me' : 'them'}" id="msg-${msg.id}">
                    <div class="msg-header">
                        <span>${msg.username}</span>
                        <span class="message-status delivered">✓</span>
                        ${statusHtml}
                    </div>
                    <div class="msg-content">${msg.text}</div>
                    <div class="msg-footer">
                        <span>${time}</span>
                        ${editedHtml}
                        ${isMe ? `
                        <div class="msg-actions">
                            <button onclick="app.editChatMessage('${msg.id}', '${msg.text.replace(/'/g, "\\'")}')" style="background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.4); color:var(--text-main); cursor:pointer; font-size:10px; padding:2px 4px; border-radius:3px; margin:0;" title="Edit message">
                                <i class="fas fa-pencil"></i>
                            </button>
                            <button onclick="app.deleteChatMessage('${msg.id}')" style="background:rgba(239,68,68,0.2); border:1px solid rgba(239,68,68,0.4); color:var(--danger); cursor:pointer; font-size:10px; padding:2px 4px; border-radius:3px; margin:0;" title="Delete for everyone">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>` : ''}
                    </div>
                </div>`;
            },
            
            // Update existing functions to use new rendering
            addLocalMessageToChat: (message) => {
                const msgsEl = document.getElementById('chatMsgs');
                if(!msgsEl) return;
                
                // Remove "No messages yet" message if it exists
                if(msgsEl.innerHTML.includes('No messages yet')) {
                    msgsEl.innerHTML = '';
                }
                
                const messageHtml = app.renderChatMessage(message, message.isLocal);
                msgsEl.insertAdjacentHTML('beforeend', messageHtml);
                msgsEl.scrollTop = msgsEl.scrollHeight;
            },
            
            loadLocalChatMessages: () => {
                const msgsEl = document.getElementById('chatMsgs');
                if(!msgsEl) return;
                
                const localMessages = JSON.parse(localStorage.getItem('local_chat_messages') || '[]');
                
                if(localMessages.length === 0) {
                    msgsEl.innerHTML = '<div style="text-align:center; color:var(--text-muted); padding:20px;">No messages yet. Start the conversation!</div>';
                } else {
                    msgsEl.innerHTML = localMessages.map(msg => app.renderChatMessage(msg, msg.isLocal)).join('');
                    msgsEl.scrollTop = msgsEl.scrollHeight;
                }
            },

            // Chat Message Edit/Delete Functions
            editChatMessage: (msgId, currentText) => {
                const newText = prompt('Edit your message:', currentText);
                if(newText === null || newText.trim() === currentText.trim()) return;
                
                const trimmedText = newText.trim();
                if(!trimmedText) {
                    alert('Message cannot be empty');
                    return;
                }
                
                // Check if it's a local message
                if(msgId.startsWith('local_')) {
                    // Update local message
                    let localMessages = JSON.parse(localStorage.getItem('local_chat_messages') || '[]');
                    const msgIndex = localMessages.findIndex(m => m.id === msgId);
                    if(msgIndex !== -1) {
                        localMessages[msgIndex].text = trimmedText;
                        localMessages[msgIndex].edited = true;
                        localMessages[msgIndex].editedAt = Date.now();
                        localStorage.setItem('local_chat_messages', JSON.stringify(localMessages));
                        
                        // Update display
                        const msgEl = document.getElementById(`msg-${msgId}`);
                        if(msgEl) {
                            const contentEl = msgEl.querySelector('.msg-content');
                            if(contentEl) {
                                contentEl.textContent = trimmedText;
                                // Add edited indicator
                                const footerEl = msgEl.querySelector('.msg-footer');
                                if(footerEl && !footerEl.innerHTML.includes('edited')) {
                                    footerEl.innerHTML += ' <span style="color:var(--text-muted); font-size:9px; font-style:italic;">edited</span>';
                                }
                            }
                        }
                    }
                } else {
                    // Update Firebase message
                    app.updateFirebaseMessage(msgId, trimmedText);
                }
            },
            
            updateFirebaseMessage: async (msgId, newText) => {
                try {
                    await updateDoc(doc(db, 'community_chat', msgId), {
                        text: newText,
                        edited: true,
                        editedAt: Date.now()
                    });
                    console.log('Message updated successfully');
                } catch(e) {
                    console.error('Update message error:', e);
                    if(e.code === 'permission-denied') {
                        alert('You can only edit your own messages');
                    } else {
                        alert('Could not edit message: ' + e.message);
                    }
                }
            },
            
            deleteChatMessage: (msgId) => {
                const confirmMessage = 'Delete this message?\n\nThis will delete the message for everyone.';
                if(!confirm(confirmMessage)) return;
                
                // Check if it's a local message
                if(msgId.startsWith('local_')) {
                    // Delete local message
                    let localMessages = JSON.parse(localStorage.getItem('local_chat_messages') || '[]');
                    localMessages = localMessages.filter(m => m.id !== msgId);
                    localStorage.setItem('local_chat_messages', JSON.stringify(localMessages));
                    
                    // Remove from display with animation
                    const msgEl = document.getElementById(`msg-${msgId}`);
                    if(msgEl) {
                        msgEl.style.opacity = '0';
                        msgEl.style.transform = 'translateY(10px)';
                        setTimeout(() => msgEl.remove(), 300);
                    }
                } else {
                    // Delete Firebase message
                    app.deleteFirebaseMessage(msgId);
                }
            },
            
            deleteFirebaseMessage: async (msgId) => {
                try {
                    // Remove from display with animation first
                    const msgEl = document.getElementById(`msg-${msgId}`);
                    if(msgEl) {
                        msgEl.style.opacity = '0';
                        msgEl.style.transform = 'translateY(10px)';
                        setTimeout(() => msgEl.remove(), 300);
                    }
                    
                    // Then delete from Firebase
                    await deleteDoc(doc(db, 'community_chat', msgId));
                    console.log('Message deleted successfully');
                } catch(e) {
                    console.error('Delete message error:', e);
                    if(e.code === 'permission-denied') {
                        alert('You can only delete your own messages');
                    } else {
                        alert('Could not delete message: ' + e.message);
                    }
                }
            },

            // User Status Management
            setUserStatus: async (status) => {
                if(!state.user) return;
                
                try {
                    console.log('Setting user status:', status);
                    await setDoc(doc(db, 'user_status', state.user.uid), {
                        uid: state.user.uid,
                        username: state.user.email.split('@')[0],
                        status: status, // 'online', 'idle', 'away'
                        lastSeen: Date.now(),
                        inChat: document.getElementById('community').classList.contains('active') // Check if community tab is active
                    }, { merge: true });
                    console.log('Status set successfully');
                } catch(e) {
                    console.error('Status update error:', e);
                    console.error('Status error details:', e.code, e.message);
                    // Don't show alert for status errors, just log them
                    // Status failures shouldn't block chat functionality
                }
            },
            
            updateUserStatusList: () => {
                const participantsEl = document.getElementById('chatParticipants');
                if(!participantsEl) return;
                
                // Get all user statuses from Firebase
                const q = query(collection(db, 'user_status'));
                getDocs(q).then(snapshot => {
                    const users = snapshot.docs.map(d => ({id: d.id, ...d.data()}));
                    
                    // Sort by status priority: online > idle > away
                    const statusPriority = { online: 0, idle: 1, away: 2 };
                    users.sort((a, b) => {
                        const aPriority = statusPriority[a.status] || 3;
                        const bPriority = statusPriority[b.status] || 3;
                        if(aPriority !== bPriority) return aPriority - bPriority;
                        return b.lastSeen - a.lastSeen; // Most recent first within same status
                    });
                    
                    if(users.length === 0) {
                        // No users in status system yet, show current user as online
                        if(state.user) {
                            const currentTime = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                            participantsEl.innerHTML = `
                            <div style="padding:5px; font-size:11px; color:var(--text-muted); display:flex; align-items:center; gap:8px; font-weight:bold;color:var(--accent);">
                                <i class="fas fa-circle" style="color: var(--success); font-size:8px;"></i>
                                <div style="flex:1;">
                                    <div>${state.user.email.split('@')[0]} (You)</div>
                                    <div style="font-size:9px; opacity:0.7;">online • ${currentTime}</div>
                                </div>
                            </div>`;
                            document.getElementById('onlineCount').textContent = '1 online';
                        } else {
                            participantsEl.innerHTML = '<div style="padding:10px; text-align:center; color:var(--text-muted); font-size:11px;">No users online</div>';
                            document.getElementById('onlineCount').textContent = '0 online';
                        }
                        return;
                    }
                    
                    participantsEl.innerHTML = users.map(user => {
                        const isMe = user.uid === state.user?.uid;
                        const statusColor = {
                            online: 'var(--success)',
                            idle: 'var(--warning)', 
                            away: 'var(--text-muted)'
                        }[user.status] || 'var(--text-muted)';
                        
                        const statusIcon = {
                            online: 'fa-circle',
                            idle: 'fa-moon',
                            away: 'fa-times-circle'
                        }[user.status] || 'fa-circle';
                        
                        const lastSeenTime = user.lastSeen ? new Date(user.lastSeen).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';
                        
                        return `
                        <div style="padding:5px; font-size:11px; color:var(--text-muted); display:flex; align-items:center; gap:8px; ${isMe ? 'font-weight:bold;color:var(--accent);' : ''}">
                            <i class="fas ${statusIcon}" style="color: ${statusColor}; font-size:8px;"></i>
                            <div style="flex:1;">
                                <div>${user.username} ${isMe ? '(You)' : ''}</div>
                                <div style="font-size:9px; opacity:0.7;">${user.status} • ${lastSeenTime}</div>
                            </div>
                        </div>`;
                    }).join('');
                    
                    // Update online count
                    const onlineCount = users.filter(u => u.status === 'online').length;
                    document.getElementById('onlineCount').textContent = `${onlineCount} online`;
                    
                }).catch(e => {
                    console.error('Error loading user statuses:', e);
                    // Fallback: show current user as online
                    if(state.user) {
                        const currentTime = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                        participantsEl.innerHTML = `
                        <div style="padding:5px; font-size:11px; color:var(--text-muted); display:flex; align-items:center; gap:8px; font-weight:bold;color:var(--accent);">
                            <i class="fas fa-circle" style="color: var(--success); font-size:8px;"></i>
                            <div style="flex:1;">
                                <div>${state.user.email.split('@')[0]} (You)</div>
                                <div style="font-size:9px; opacity:0.7;">online • ${currentTime}</div>
                            </div>
                        </div>`;
                        document.getElementById('onlineCount').textContent = '1 online';
                    } else {
                        participantsEl.innerHTML = '<div style="padding:10px; text-align:center; color:var(--text-muted); font-size:11px;">Sign in to see users</div>';
                        document.getElementById('onlineCount').textContent = '0 online';
                    }
                });
            },
            
            startStatusTracking: () => {
                // Set user as online when in community section
                app.setUserStatus('online');
                
                // Update status every 30 seconds
                if(app.statusInterval) clearInterval(app.statusInterval);
                app.statusInterval = setInterval(() => {
                    // Check if user is in community section (chat is always visible now)
                    const communityActive = document.getElementById('community').classList.contains('active');
                    if(communityActive) {
                        app.setUserStatus('online');
                    } else {
                        app.setUserStatus('idle');
                    }
                }, 30000);
            },
            
            stopStatusTracking: () => {
                if(app.statusInterval) {
                    clearInterval(app.statusInterval);
                    app.statusInterval = null;
                }
                // Don't set as away - let the natural status tracking handle it
                // app.setUserStatus('away'); // REMOVED - This was causing the bug
            },

            getStreak: (filterName = null) => {
                let streak = 0;
                let today = new Date();
                today.setHours(0,0,0,0);
                const getIsoDate = (d) => {
                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                };
                const cleanText = (txt) => txt.replace(/#\w+/g, '').trim();

                if(!filterName) {
                    const todayStr = getIsoDate(today);
                    const tasksToday = state.tasks.filter(t => t.date === todayStr);
                    if (tasksToday.length > 0 && tasksToday.every(t => t.completed)) streak++;
                    
                    let checkDate = new Date(today);
                    checkDate.setDate(checkDate.getDate() - 1);
                    while (true) {
                        const dateStr = getIsoDate(checkDate);
                        const tasksOnDate = state.tasks.filter(t => t.date === dateStr);
                        if (tasksOnDate.length === 0) break;
                        if (tasksOnDate.every(t => t.completed)) {
                            streak++;
                            checkDate.setDate(checkDate.getDate() - 1);
                        } else break;
                    }
                    return streak;
                } else {
                    const todayStr = getIsoDate(today);
                    const doneToday = state.tasks.some(t => t.date === todayStr && cleanText(t.text) === filterName && t.completed);
                    if(doneToday) streak++;

                    let checkDate = new Date(today);
                    checkDate.setDate(checkDate.getDate() - 1);
                    while(true) {
                        const dateStr = getIsoDate(checkDate);
                        const doneOnDate = state.tasks.some(t => t.date === dateStr && cleanText(t.text) === filterName && t.completed);
                        if (doneOnDate) { streak++; checkDate.setDate(checkDate.getDate() - 1); } else { break; }
                    }
                    return streak;
                }
            },

            updateSubStreak: () => {
                const select = document.getElementById('subStreakSelect');
                const val = select.value;
                state.subStreakTask = val;
                localStorage.setItem('subStreakTask', val);
                const count = val ? app.getStreak(val) : 0;
                document.getElementById('subStreakCount').textContent = count;
            },

            // New Goal Setting
            setDailyGoal: (val) => {
                state.dailyGoal = parseInt(val) || 3;
                localStorage.setItem('dailyGoal', state.dailyGoal);
                document.getElementById('goalTargetDisplay').textContent = state.dailyGoal + 'h';
                app.renderDashboardCharts(); // Re-render to update progress
            },

            // NEW: Reset All Focus Data
            resetFocusData: async () => {
                if(!confirm("Reset ALL focus timer history? This cannot be undone.")) return;
                state.focusLogs = [];
                localStorage.setItem('focusLogs', JSON.stringify([]));
                
                if(state.user) {
                    try {
                        const batch = writeBatch(db);
                        const q = query(collection(db, 'focus_sessions'), where('uid', '==', state.user.uid));
                        const snapshot = await getDocs(q);
                        snapshot.forEach(doc => batch.delete(doc.ref));
                        await batch.commit();
                    } catch(e) { console.error("Error clearing cloud logs", e); }
                }
                app.renderDashboardCharts();
            },

            // NEW: Edit specific task time (Adjustment)
            editTaskFocus: async (taskName) => {
                // Find current total duration for this task
                let currentDuration = 0;
                state.focusLogs.forEach(log => {
                    const name = log.taskTitle || 'Unknown Task';
                    // Match by name for aggregation consistency
                    if (name === taskName) currentDuration += (log.duration || 0);
                });

                const currentMins = Math.round(currentDuration / 60);
                const newVal = prompt(`Update total focus time for "${taskName}" (in minutes):`, currentMins);
                if (newVal === null) return;
                
                const newMins = parseInt(newVal);
                if (isNaN(newMins) || newMins < 0) return alert("Invalid time.");

                const diffSeconds = (newMins * 60) - currentDuration;
                if (Math.abs(diffSeconds) < 1) return; // No change

                // Create adjustment log
                const log = {
                    duration: diffSeconds,
                    timestamp: Date.now(),
                    taskTitle: taskName,
                    taskId: null, // manual adjustment
                    isAdjustment: true
                };

                state.focusLogs.push(log);
                localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));

                if(state.user) {
                     addDoc(collection(db, 'focus_sessions'), { 
                        uid: state.user.uid,
                        ...log
                    }).catch(e => console.error(e));
                }
                app.renderDashboardCharts();
            },

            // NEW: Reset specific task time
            resetTaskFocus: async (taskName) => {
                if(!confirm(`Remove all focus history for "${taskName}"?`)) return;
                
                // Filter out logs with this task title
                const logsToRemove = state.focusLogs.filter(log => (log.taskTitle || 'Unknown Task') === taskName);
                state.focusLogs = state.focusLogs.filter(log => (log.taskTitle || 'Unknown Task') !== taskName);
                localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));

                if(state.user) {
                    try {
                        const batch = writeBatch(db);
                        const q = query(collection(db, 'focus_sessions'), where('uid', '==', state.user.uid), where('taskTitle', '==', taskName));
                        const snapshot = await getDocs(q);
                        snapshot.forEach(doc => batch.delete(doc.ref));
                        await batch.commit();
                    } catch(e) { console.error(e); }
                }
                app.renderDashboardCharts();
            },

            renderDashboardCharts: () => {
                const timeFilter = document.getElementById('dashFilterTime').value;
                const tagFilter = document.getElementById('dashFilterTag').value;
                let filtered = state.tasks;
                const now = new Date();
                
                const currentStreak = app.getStreak(null);
                document.getElementById('streakCount').textContent = currentStreak;
                const streakIcon = document.getElementById('streakIcon');
                if(currentStreak > 0) {
                    streakIcon.style.opacity = '1'; streakIcon.style.color = '#f97316'; streakIcon.classList.add('fa-beat');
                } else {
                    streakIcon.style.opacity = '0.3'; streakIcon.style.color = 'var(--text-muted)'; streakIcon.classList.remove('fa-beat');
                }

                // ==========================================
                //  UPDATED FOCUS ANALYTICS LOGIC (THE FIX)
                // ==========================================
                
                let focusSeconds = 0;
                const logs = state.focusLogs || [];
                const taskStats = {}; // To hold accumulated time per task
                
                const validTaskIds = new Set(state.tasks.map(t => t.id));

                logs.forEach(log => {
                    // Check if linked task exists (if linked via ID)
                    if (log.taskId && !validTaskIds.has(log.taskId)) {
                        return; // Skip deleted task logs
                    }

                    const logDate = new Date(log.timestamp);
                    let include = false;
                    if(timeFilter === 'all') include = true;
                    else if(timeFilter === 'daily') include = logDate.toDateString() === now.toDateString();
                    else if(timeFilter === 'weekly') { const ago = new Date(); ago.setDate(now.getDate() - 7); include = logDate >= ago; }
                    else if(timeFilter === 'monthly') include = logDate.getMonth() === now.getMonth() && logDate.getFullYear() === now.getFullYear();
                    else if(timeFilter === 'yearly') include = logDate.getFullYear() === now.getFullYear();
                    
                    if(include) {
                        focusSeconds += (log.duration || 0);
                        
                        // Accumulate for specific task breakdown
                        // Prefer current task name if ID exists, else fallback to log title
                        let name = log.taskTitle || 'Unknown Task';
                        if (log.taskId) {
                            const currentTask = state.tasks.find(t => t.id === log.taskId);
                            if (currentTask) name = currentTask.text;
                        }
                        
                        taskStats[name] = (taskStats[name] || 0) + log.duration;
                    }
                });

                // Prevent negative time display if adjustments pushed it below zero
                if(focusSeconds < 0) focusSeconds = 0;

                const hrs = Math.floor(focusSeconds / 3600);
                const mins = Math.floor((focusSeconds % 3600) / 60);
                document.getElementById('focusTimeDisplay').textContent = `${hrs}h ${mins}m`;
                
                // Goal Calculation
                let goalProgress = 0;
                let displayPercent = "0%";
                
                if(timeFilter === 'daily') {
                    document.getElementById('focusTimeLabel').textContent = "Today";
                    const goalSecs = state.dailyGoal * 3600;
                    if (goalSecs > 0) {
                        goalProgress = (focusSeconds / goalSecs) * 100;
                        // PRECISION LOGIC
                        if (goalProgress > 0 && goalProgress < 1) {
                            displayPercent = goalProgress.toFixed(2) + "%";
                        } else {
                            displayPercent = Math.round(goalProgress) + "%";
                        }
                        if (goalProgress > 100) goalProgress = 100; // cap bar fill
                    }
                } else {
                    document.getElementById('focusTimeLabel').textContent = timeFilter === 'all' ? "Total" : timeFilter;
                    goalProgress = 0; 
                }
                
                document.getElementById('goalProgressBar').style.width = Math.min(goalProgress, 100) + '%';
                document.getElementById('goalPercentDisplay').textContent = displayPercent;

                // RENDER TASK BREAKDOWN LIST
                const taskListEl = document.getElementById('taskFocusList');
                // Filter out tasks with <= 0 duration (from adjustments)
                const sortedTasks = Object.entries(taskStats)
                    .filter(([_, dur]) => dur > 0)
                    .sort((a,b) => b[1] - a[1]); 
                
                if (sortedTasks.length === 0) {
                    taskListEl.innerHTML = `<div style="font-size:12px; color:var(--text-muted); font-style:italic;">No specific task data yet.</div>`;
                } else {
                    taskListEl.innerHTML = sortedTasks.map(([name, dur]) => {
                        const h = Math.floor(dur / 3600);
                        const m = Math.floor((dur % 3600) / 60);
                        // Escape quotes for onclick
                        const safeName = name.replace(/'/g, "\\'");
                        return `
                        <div class="focus-task-row">
                            <span class="focus-task-name">${name.length > 25 ? name.substring(0,25)+'...' : name}</span>
                            <span class="focus-task-time">${h > 0 ? h+'h ' : ''}${m}m</span>
                            <div class="focus-task-actions">
                                <i class="fas fa-pencil focus-icon-btn" onclick="app.editTaskFocus('${safeName}')" title="Edit Time"></i>
                                <i class="fas fa-trash focus-icon-btn" onclick="app.resetTaskFocus('${safeName}')" title="Remove from list"></i>
                            </div>
                        </div>`;
                    }).join('');
                }
                
                // End Focus Analytics Update

                const subSelect = document.getElementById('subStreakSelect');
                const cleanText = (txt) => txt.replace(/#\w+/g, '').trim();
                const allTaskNames = new Set([...state.history, ...state.tasks.map(t => cleanText(t.text))]);
                
                while(subSelect.options.length > 1) { subSelect.remove(1); }
                allTaskNames.forEach(name => {
                    if(!name) return;
                    const opt = document.createElement('option');
                    opt.value = name; opt.textContent = name;
                    if(name === state.subStreakTask) opt.selected = true;
                    subSelect.appendChild(opt);
                });
                app.updateSubStreak();

                if (timeFilter !== 'all') {
                    filtered = filtered.filter(t => {
                        const d = new Date(t.date);
                        if(timeFilter === 'daily') return d.toDateString() === now.toDateString();
                        if(timeFilter === 'weekly') { const ago = new Date(); ago.setDate(now.getDate() - 7); return d >= ago && d <= now; }
                        if(timeFilter === 'monthly') return d.getMonth() === now.getMonth();
                        if(timeFilter === 'yearly') return d.getFullYear() === now.getFullYear();
                        return true;
                    });
                }
                if (tagFilter !== 'all') filtered = filtered.filter(t => (t.tags||[]).includes(tagFilter));

                // FIXED: Subtask Counting Logic
                let totalCount = 0;
                let doneCount = 0;
                
                filtered.forEach(t => {
                    totalCount++; // The task itself
                    if(t.completed) doneCount++;
                    
                    if(t.subtasks && t.subtasks.length > 0) {
                        totalCount += t.subtasks.length;
                        doneCount += t.subtasks.filter(s => s.completed).length;
                    }
                });

                document.getElementById('dashTotal').textContent = totalCount;
                document.getElementById('dashDone').textContent = doneCount;
                document.getElementById('dashPending').textContent = totalCount - doneCount;

                const allTags = [...new Set(state.tasks.flatMap(t => t.tags || []))];
                const tagSelect = document.getElementById('dashFilterTag');
                if(tagSelect.options.length === 1) { 
                    allTags.forEach(tag => {
                        const opt = document.createElement('option'); opt.value = tag; opt.textContent = '#' + tag; tagSelect.appendChild(opt);
                    });
                }

                const ctx1 = document.getElementById('mainChart').getContext('2d');
                if(state.charts.main) state.charts.main.destroy();
                const labels = [], dataPoints = [];
                for(let i=6; i>=0; i--) {
                    const d = new Date(); d.setDate(d.getDate() - i);
                    const k = d.toISOString().split('T')[0];
                    labels.push(k.slice(5));
                    dataPoints.push(state.tasks.filter(t => t.date === k && t.completed).length);
                }
                state.charts.main = new Chart(ctx1, {
                    type: 'line',
                    data: { labels: labels, datasets: [{ label: 'Completed', data: dataPoints, borderColor: getComputedStyle(document.body).getPropertyValue('--accent'), tension: 0.4 }] },
                    options: { maintainAspectRatio: false, plugins: { legend: {display:false} } }
                });

                const ctx2 = document.getElementById('tagChart').getContext('2d');
                if(state.charts.tags) state.charts.tags.destroy();
                const tagCounts = {};
                filtered.forEach(t => (t.tags||[]).forEach(tag => tagCounts[tag] = (tagCounts[tag]||0)+1));
                state.charts.tags = new Chart(ctx2, {
                    type: 'doughnut',
                    data: { labels: Object.keys(tagCounts), datasets: [{ data: Object.values(tagCounts), backgroundColor: ['#208084', '#10b981', '#f59e0b', '#ef4444', '#6366f1'] }] },
                    options: { maintainAspectRatio: false }
                });
                
                // Render Focus Timeline with delete/reset options
                const timelineEl = document.getElementById('focusTimeline');
                const sortedLogs = logs
                    .filter(log => log.duration > 0)
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, 10);
                
                if (sortedLogs.length === 0) {
                    timelineEl.innerHTML = `<div style="font-size:12px; color:var(--text-muted); font-style:italic;">No focus sessions yet.</div>`;
                } else {
                    timelineEl.innerHTML = sortedLogs.map(log => {
                        const date = new Date(log.timestamp);
                        const dateStr = date.toLocaleDateString();
                        const timeStr = date.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                        const mins = Math.round(log.duration / 60);
                        const hrs = Math.floor(mins / 60);
                        const remainingMins = mins % 60;
                        const timeDisplay = hrs > 0 ? `${hrs}h ${remainingMins}m` : `${mins}m`;
                        
                        let taskName = log.taskTitle || 'General Focus';
                        if(log.taskId) {
                            const currentTask = state.tasks.find(t => t.id === log.taskId);
                            if(currentTask) taskName = currentTask.text;
                        }
                        
                        const logId = log.id || log.timestamp;
                        
                        return `
                        <div class="focus-task-row" style="display:flex; justify-content:space-between; align-items:center; padding:8px; margin-bottom:5px; background:var(--bg-body); border-radius:4px;">
                            <div style="flex:1;">
                                <span class="focus-task-name">${taskName.length > 20 ? taskName.substring(0,20)+'...' : taskName}</span>
                                <span class="focus-task-time" style="margin-left:10px; color:var(--accent);">${timeDisplay}</span>
                                <span style="font-size:10px; color:var(--text-muted); margin-left:10px;">${dateStr} ${timeStr}</span>
                            </div>
                            <button class="btn btn-icon btn-danger" style="width:24px;height:24px;padding:0;font-size:10px;" onclick="app.deleteFocusLog('${logId}')" title="Delete session">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>`;
                    }).join('');
                    
                    // Add reset all button
                    timelineEl.innerHTML += `
                        <div style="margin-top:15px; padding-top:10px; border-top:1px solid var(--border);">
                            <button class="btn btn-danger" style="width:100%;" onclick="app.resetAllFocusLogs()">
                                <i class="fas fa-trash"></i> Reset All Focus Sessions
                            </button>
                        </div>
                    `;
                }
            },
            
            deleteFocusLog: async (logId) => {
                if(!confirm('Delete this focus session?')) return;
                
                if(state.user) {
                    // Find and delete from Firebase
                    const q = query(collection(db, 'focus_sessions'), where('uid', '==', state.user.uid), where('timestamp', '==', parseInt(logId)));
                    const snapshot = await getDocs(q);
                    snapshot.forEach(async (doc) => {
                        await deleteDoc(doc.ref);
                    });
                } else {
                    // Delete from local state
                    state.focusLogs = state.focusLogs.filter(log => log.timestamp !== parseInt(logId));
                    localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));
                    app.renderDashboardCharts();
                }
            },
            
            resetAllFocusLogs: async () => {
                if(!confirm('Delete ALL focus sessions? This cannot be undone.')) return;
                
                if(state.user) {
                    // Delete all user's focus sessions from Firebase
                    const q = query(collection(db, 'focus_sessions'), where('uid', '==', state.user.uid));
                    const snapshot = await getDocs(q);
                    const batch = writeBatch(db);
                    snapshot.forEach(doc => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();
                } else {
                    // Clear local focus logs
                    state.focusLogs = [];
                    localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));
                    app.renderDashboardCharts();
                }
            },

            // Habit Challenges functionality
            showAddHabitModal: () => {
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:1000;';
                modal.innerHTML = `
                    <div style="background:var(--bg-card);padding:30px;border-radius:12px;max-width:400px;width:90%;">
                        <h3 style="color:var(--text-main);margin-bottom:20px;">Add New Habit</h3>
                        <input type="text" id="habitTitle" class="main-input" placeholder="Habit name..." style="width:100%;margin-bottom:15px;padding:10px;background:var(--bg-input);border:1px solid var(--border);border-radius:6px;color:var(--text-main);">
                        <textarea id="habitDescription" class="main-input" placeholder="Description (optional)..." rows="3" style="width:100%;margin-bottom:15px;padding:10px;background:var(--bg-input);border:1px solid var(--border);border-radius:6px;color:var(--text-main);resize:vertical;"></textarea>
                        <select id="habitChallenge" style="width:100%;margin-bottom:15px;padding:10px;background:var(--bg-input);border:1px solid var(--border);border-radius:6px;color:var(--text-main);">
                            <option value="7">7 Day Challenge</option>
                            <option value="21">21 Day Challenge</option>
                            <option value="custom">Custom Days</option>
                        </select>
                        <input type="number" id="habitCustomDays" placeholder="Custom days" min="1" style="width:100%;margin-bottom:20px;padding:10px;background:var(--bg-input);border:1px solid var(--border);border-radius:6px;color:var(--text-main);display:none;">
                        <div style="display:flex;gap:10px;">
                            <button class="btn btn-primary" onclick="app.addHabit()">Add Habit</button>
                            <button class="btn btn-secondary" onclick="this.closest('[style*=position]').remove()">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Show custom days input when custom is selected
                document.getElementById('habitChallenge').onchange = function() {
                    document.getElementById('habitCustomDays').style.display = this.value === 'custom' ? 'block' : 'none';
                };
            },
            
            addHabit: async () => {
                const title = document.getElementById('habitTitle').value.trim();
                const description = document.getElementById('habitDescription').value.trim();
                const challengeType = document.getElementById('habitChallenge').value;
                const customDays = challengeType === 'custom' ? parseInt(document.getElementById('habitCustomDays').value) : parseInt(challengeType);
                const targetDays = customDays || 7;
                
                if(!title) {
                    alert('Please enter a habit name');
                    return;
                }
                
                const newHabit = {
                    title,
                    description,
                    targetDays,
                    currentStreak: 0,
                    completedDates: [],
                    createdAt: Date.now(),
                    lastCompleted: null,
                    isActive: true
                };
                
                if(state.user) {
                    try {
                        const docRef = await addDoc(collection(db, 'habits'), { ...newHabit, uid: state.user.uid });
                        // Update local state with Firebase ID
                        newHabit.id = docRef.id;
                        state.habits = state.habits || [];
                        state.habits.push(newHabit);
                        console.log('Habit added successfully with ID:', docRef.id);
                    } catch(e) {
                        console.error('Error adding habit to Firebase:', e);
                        alert('Could not save habit to cloud. Please try again.');
                        return;
                    }
                } else {
                    newHabit.id = 'local_' + Date.now();
                    state.habits = state.habits || [];
                    state.habits.push(newHabit);
                    localStorage.setItem('habits', JSON.stringify(state.habits));
                    app.renderHabits();
                }
                
                document.querySelector('[style*=position]').remove();
            },
            
            toggleHabitCompletion: async (habitId) => {
                const habit = state.habits.find(h => h.id === habitId);
                if(!habit) return;
                
                const today = new Date().toISOString().split('T')[0];
                const isCompletedToday = habit.completedDates.includes(today);
                
                if(isCompletedToday) {
                    // Uncomplete for today
                    habit.completedDates = habit.completedDates.filter(date => date !== today);
                    habit.currentStreak = Math.max(0, habit.currentStreak - 1);
                } else {
                    // Complete for today
                    habit.completedDates.push(today);
                    habit.currentStreak += 1;
                    habit.lastCompleted = today;
                }
                
                if(state.user) {
                    try {
                        await updateDoc(doc(db, 'habits', habitId), {
                            completedDates: habit.completedDates,
                            currentStreak: habit.currentStreak,
                            lastCompleted: habit.lastCompleted
                        });
                        console.log('Habit completion updated successfully');
                    } catch(e) {
                        console.error('Error updating habit completion:', e);
                        alert('Could not update habit. Please try again.');
                        // Revert local changes
                        if(isCompletedToday) {
                            habit.completedDates.push(today);
                            habit.currentStreak += 1;
                        } else {
                            habit.completedDates = habit.completedDates.filter(date => date !== today);
                            habit.currentStreak = Math.max(0, habit.currentStreak - 1);
                        }
                        return;
                    }
                } else {
                    localStorage.setItem('habits', JSON.stringify(state.habits));
                    app.renderHabits();
                }
            },
            
            deleteHabit: async (habitId) => {
                if(!confirm('Permanently delete this habit?')) return;
                
                if(state.user) {
                    try {
                        await deleteDoc(doc(db, 'habits', habitId));
                        // Update local state
                        state.habits = state.habits.filter(h => h.id !== habitId);
                        console.log('Habit deleted successfully');
                    } catch(e) {
                        console.error('Error deleting habit:', e);
                        alert('Could not delete habit. Please try again.');
                        return;
                    }
                } else {
                    state.habits = state.habits.filter(h => h.id !== habitId);
                    localStorage.setItem('habits', JSON.stringify(state.habits));
                    app.renderHabits();
                }
            },
            
            editHabit: (habitId) => {
                const habit = state.habits.find(h => h.id === habitId);
                if(!habit) return;
                
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:1000;';
                modal.innerHTML = `
                    <div style="background:var(--bg-card);padding:30px;border-radius:12px;max-width:400px;width:90%;">
                        <h3 style="color:var(--text-main);margin-bottom:20px;">Edit Habit</h3>
                        <input type="text" id="habitTitle" class="main-input" value="${habit.title}" style="width:100%;margin-bottom:15px;padding:10px;background:var(--bg-input);border:1px solid var(--border);border-radius:6px;color:var(--text-main);">
                        <textarea id="habitDescription" class="main-input" rows="3" style="width:100%;margin-bottom:15px;padding:10px;background:var(--bg-input);border:1px solid var(--border);border-radius:6px;color:var(--text-main);resize:vertical;">${habit.description || ''}</textarea>
                        <div style="display:flex;gap:10px;">
                            <button class="btn btn-primary" onclick="app.updateHabit('${habitId}')">Update</button>
                            <button class="btn btn-secondary" onclick="this.closest('[style*=position]').remove()">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },
            
            updateHabit: async (habitId) => {
                const habit = state.habits.find(h => h.id === habitId);
                if(!habit) return;
                
                const title = document.getElementById('habitTitle').value.trim();
                const description = document.getElementById('habitDescription').value.trim();
                
                if(!title) {
                    alert('Please enter a habit name');
                    return;
                }
                
                habit.title = title;
                habit.description = description;
                
                if(state.user) {
                    try {
                        await updateDoc(doc(db, 'habits', habitId), { title, description });
                        console.log('Habit updated successfully');
                    } catch(e) {
                        console.error('Error updating habit:', e);
                        alert('Could not update habit. Please try again.');
                        return;
                    }
                } else {
                    localStorage.setItem('habits', JSON.stringify(state.habits));
                    app.renderHabits();
                }
                
                document.querySelector('[style*=position]').remove();
            },
            
            renderHabits: () => {
                const list = document.getElementById('habitsList');
                list.innerHTML = '';
                
                const habits = state.habits || [];
                
                if(habits.length === 0) {
                    list.innerHTML = '<div style="text-align:center;color:var(--text-muted);margin-top:40px;">No habits yet. Start building better habits today!</div>';
                    return;
                }
                
                habits.forEach(habit => {
                    const today = new Date().toISOString().split('T')[0];
                    const isCompletedToday = habit.completedDates.includes(today);
                    const progress = (habit.currentStreak / habit.targetDays) * 100;
                    const isCompleted = habit.currentStreak >= habit.targetDays;
                    
                    const habitCard = document.createElement('div');
                    habitCard.className = 'task-card';
                    habitCard.style.cssText = `border-left: 4px solid ${isCompleted ? 'var(--success)' : 'var(--accent)'}`;
                    
                    habitCard.innerHTML = `
                        <div style="display:flex; align-items:center; gap:15px;">
                            <input type="checkbox" ${isCompletedToday ? 'checked' : ''} onchange="app.toggleHabitCompletion('${habit.id}')" style="width:24px;height:24px;">
                            <div style="flex:1;">
                                <div style="font-weight:600; color:var(--text-main); margin-bottom:5px;">
                                    ${habit.title} ${isCompleted ? '<i class="fas fa-trophy" style="color:var(--success); margin-left:10px;"></i>' : ''}
                                </div>
                                ${habit.description ? `<div style="font-size:12px; color:var(--text-muted); margin-bottom:10px;">${habit.description}</div>` : ''}
                                <div style="display:flex; align-items:center; gap:15px;">
                                    <div style="font-size:12px; color:var(--text-muted);">
                                        <i class="fas fa-fire" style="color:var(--streak-fire);"></i> ${habit.currentStreak}/${habit.targetDays} days
                                    </div>
                                    <div style="font-size:12px; color:var(--text-muted);">
                                        ${Math.round(progress)}% complete
                                    </div>
                                </div>
                                <div style="width:100%; height:6px; background:var(--bg-input); border-radius:3px; margin-top:8px; overflow:hidden;">
                                    <div style="width:${progress}%; height:100%; background:${isCompleted ? 'var(--success)' : 'var(--accent)'}; transition:width 0.3s;"></div>
                                </div>
                            </div>
                            <div style="display:flex; gap:5px;">
                                <button class="btn btn-icon" onclick="app.editHabit('${habit.id}')"><i class="fas fa-pencil"></i></button>
                                <button class="btn btn-icon btn-danger" onclick="app.deleteHabit('${habit.id}')"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>
                    `;
                    
                    list.appendChild(habitCard);
                });
            },

            focusOnTask: (id) => { app.switchTab('focus'); document.getElementById('focusTaskSelect').value = id; },
            
            
            loadFocusTasks: () => {
                const sel = document.getElementById('focusTaskSelect');
                const currentVal = sel.value;
                sel.innerHTML = '<option value="">-- No specific task --</option>';
                state.tasks.filter(t => !t.completed).forEach(t => {
                    const opt = document.createElement('option'); opt.value = t.id; opt.textContent = t.text;
                    if(t.id === currentVal) opt.selected = true;
                    sel.appendChild(opt);
                });
            }
        };

        // =======================================================
        //  AUDIO ENGINE & FOCUS TIMER LOGIC
        // =======================================================

        const AudioEngine = {
            ctx: null,
            activeNodes: [],
            gainNode: null,
            alarmInterval: null,
            alarmOsc: null,

            init: () => {
                if(!AudioEngine.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    AudioEngine.ctx = new AudioContext();
                }
                if(AudioEngine.ctx.state === 'suspended') {
                    AudioEngine.ctx.resume();
                }
            },

            playBeep: (type) => {
                AudioEngine.init();
                const t = AudioEngine.ctx.currentTime;
                const osc = AudioEngine.ctx.createOscillator();
                const gain = AudioEngine.ctx.createGain();
                osc.connect(gain);
                gain.connect(AudioEngine.ctx.destination);

                if (type === 'start') {
                    osc.frequency.setValueAtTime(440, t);
                    osc.frequency.exponentialRampToValueAtTime(880, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                    osc.start(t);
                    osc.stop(t + 0.5);
                }
            },

            // NEW: Continuous Alarm Function
            playAlarm: () => {
                AudioEngine.init();
                // Stop any existing alarm
                if(AudioEngine.alarmInterval) clearInterval(AudioEngine.alarmInterval);
                
                const playPulse = () => {
                    const t = AudioEngine.ctx.currentTime;
                    const osc = AudioEngine.ctx.createOscillator();
                    const gain = AudioEngine.ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(AudioEngine.ctx.destination);
                    
                    osc.frequency.setValueAtTime(880, t); // A5
                    osc.frequency.setValueAtTime(1100, t + 0.2); // Just a bit higher
                    
                    gain.gain.setValueAtTime(0.2, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                    
                    osc.type = 'square';
                    osc.start(t);
                    osc.stop(t + 0.5);
                };

                // Play immediately
                playPulse();
                // Repeat every second
                AudioEngine.alarmInterval = setInterval(playPulse, 1000);
            },

            stopAlarm: () => {
                if(AudioEngine.alarmInterval) {
                    clearInterval(AudioEngine.alarmInterval);
                    AudioEngine.alarmInterval = null;
                }
            },

            createNoiseBuffer: () => {
                const bufferSize = AudioEngine.ctx.sampleRate * 2; 
                const buffer = AudioEngine.ctx.createBuffer(1, bufferSize, AudioEngine.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                return buffer;
            },

            playBackground: (type) => {
                AudioEngine.stopBackground();
                if(type === 'none') return;
                AudioEngine.init();
                const t = AudioEngine.ctx.currentTime;
                
                AudioEngine.gainNode = AudioEngine.ctx.createGain();
                AudioEngine.gainNode.gain.setValueAtTime(0.1, t);
                AudioEngine.gainNode.connect(AudioEngine.ctx.destination);

                // NOISE BASED
                if (['white', 'wind', 'rain', 'brown', 'ocean', 'fan'].includes(type)) {
                    const noise = AudioEngine.ctx.createBufferSource();
                    noise.buffer = AudioEngine.createNoiseBuffer();
                    noise.loop = true;
                    
                    let finalNode = noise;

                    if (type === 'wind' || type === 'rain') { 
                        const filter = AudioEngine.ctx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = type === 'wind' ? 400 : 800; 
                        noise.connect(filter);
                        finalNode = filter;
                    } 
                    if (type === 'brown') {
                         const filter = AudioEngine.ctx.createBiquadFilter();
                         filter.type = 'lowpass';
                         filter.frequency.value = 150;
                         noise.connect(filter);
                         finalNode = filter;
                    }
                    if (type === 'ocean') {
                        const filter = AudioEngine.ctx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.Q.value = 1;
                        noise.connect(filter);
                        // LFO for waves
                        const lfo = AudioEngine.ctx.createOscillator();
                        lfo.type = 'sine';
                        lfo.frequency.value = 0.1; 
                        const lfoGain = AudioEngine.ctx.createGain();
                        lfoGain.gain.value = 300;
                        lfo.connect(lfoGain);
                        lfoGain.connect(filter.frequency);
                        filter.frequency.setValueAtTime(400, t);
                        lfo.start();
                        AudioEngine.activeNodes.push(lfo);
                        finalNode = filter;
                    }
                    if (type === 'fan') {
                        const filter = AudioEngine.ctx.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.value = 150;
                        filter.Q.value = 2;
                        noise.connect(filter);
                        finalNode = filter;
                    }

                    finalNode.connect(AudioEngine.gainNode);
                    noise.start();
                    AudioEngine.activeNodes.push(noise);
                } 
                
                if (type === 'beats') {
                    const osc1 = AudioEngine.ctx.createOscillator();
                    const osc2 = AudioEngine.ctx.createOscillator();
                    osc1.frequency.value = 200;
                    osc2.frequency.value = 205; 
                    osc1.connect(AudioEngine.gainNode);
                    osc2.connect(AudioEngine.gainNode);
                    osc1.start(); osc2.start();
                    AudioEngine.activeNodes.push(osc1, osc2);
                }

                if (type === 'forest') {
                    // Improved Forest: Pink Noise (Leaves) + Random Chirps
                    const noise = AudioEngine.ctx.createBufferSource();
                    noise.buffer = AudioEngine.createNoiseBuffer();
                    noise.loop = true;
                    const filter = AudioEngine.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 500;
                    noise.connect(filter);
                    const noiseGain = AudioEngine.ctx.createGain();
                    noiseGain.gain.value = 0.3;
                    filter.connect(noiseGain);
                    noiseGain.connect(AudioEngine.gainNode);
                    noise.start();
                    AudioEngine.activeNodes.push(noise);

                    // Random Bird Chirps
                    const playChirp = () => {
                        if(AudioEngine.activeNodes.length === 0) return; // Stopped
                        const osc = AudioEngine.ctx.createOscillator();
                        const g = AudioEngine.ctx.createGain();
                        osc.frequency.setValueAtTime(1500 + Math.random()*1000, AudioEngine.ctx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(1000 + Math.random()*500, AudioEngine.ctx.currentTime + 0.1);
                        g.gain.setValueAtTime(0, AudioEngine.ctx.currentTime);
                        g.gain.linearRampToValueAtTime(0.1, AudioEngine.ctx.currentTime + 0.05);
                        g.gain.linearRampToValueAtTime(0, AudioEngine.ctx.currentTime + 0.2);
                        osc.connect(g);
                        g.connect(AudioEngine.gainNode);
                        osc.start(); osc.stop(AudioEngine.ctx.currentTime + 0.2);
                        setTimeout(playChirp, 1000 + Math.random() * 4000);
                    };
                    playChirp();
                }

                if (type === 'night') {
                    // Crickets: High freq Osc with amplitude modulation
                    const car = AudioEngine.ctx.createOscillator();
                    car.frequency.value = 4500;
                    const mod = AudioEngine.ctx.createOscillator();
                    mod.type = 'square';
                    mod.frequency.value = 10;
                    const modGain = AudioEngine.ctx.createGain();
                    modGain.gain.value = 1000;
                    
                    const masterG = AudioEngine.ctx.createGain();
                    masterG.gain.value = 0.05;
                    
                    mod.connect(masterG.gain);
                    car.connect(masterG);
                    masterG.connect(AudioEngine.gainNode);
                    
                    car.start(); mod.start();
                    AudioEngine.activeNodes.push(car, mod);
                }
            },

            stopBackground: () => {
                AudioEngine.activeNodes.forEach(n => { try{n.stop();}catch(e){}});
                AudioEngine.activeNodes = [];
                if(AudioEngine.gainNode) { AudioEngine.gainNode.disconnect(); AudioEngine.gainNode = null; }
            }
        };

        window.focusMode = {
            timerInterval: null,
            status: 'idle', // 'idle', 'running', 'paused', 'break'
            pausedType: null, // to track if we paused 'focus' or 'break'
            endTime: 0,
            remainingAtPause: 0,
            totalDuration: 0,
            alarmTimeout: null,
            
            syncTimerState: async () => {
                if(!state.user) return;
                const data = {
                    status: focusMode.status,
                    endTime: focusMode.endTime,
                    remainingAtPause: focusMode.remainingAtPause,
                    totalDuration: focusMode.totalDuration,
                    pausedType: focusMode.pausedType || null,
                    updatedAt: Date.now()
                };
                try {
                    await setDoc(doc(db, 'timers', state.user.uid), data, {merge: true});
                } catch(e) { console.error("Sync timer error", e); }
            },

            start: (type) => {
                // Check if we are resuming the correct type
                if (focusMode.status === 'paused' && focusMode.pausedType === type) {
                    focusMode.endTime = Date.now() + focusMode.remainingAtPause;
                    focusMode.status = type;
                    focusMode.pausedType = null;
                } else {
                    // Start fresh
                    let mins = parseInt(document.getElementById(type === 'focus' ? 'focusDuration' : 'breakDuration').value) || 25;
                    focusMode.totalDuration = mins * 60 * 1000;
                    focusMode.endTime = Date.now() + focusMode.totalDuration;
                    focusMode.status = type;
                    focusMode.pausedType = null;
                }

                focusMode.updateUI(true);
                AudioEngine.playBeep('start');
                AudioEngine.playBackground(document.getElementById('soundSelect').value);
                
                focusMode.runLoop();
                focusMode.syncTimerState();
            },

            togglePause: () => {
                if(focusMode.status === 'idle') return;

                if (focusMode.status === 'paused') {
                    // Resume based on what was paused
                    const resumeType = focusMode.pausedType || 'focus';
                    focusMode.start(resumeType);
                } else {
                    // Pause
                    const now = Date.now();
                    focusMode.remainingAtPause = Math.max(0, focusMode.endTime - now);
                    focusMode.pausedType = focusMode.status; // Remember what we paused
                    focusMode.status = 'paused';
                    
                    focusMode.updateUI(false);
                    AudioEngine.stopBackground();
                    clearInterval(focusMode.timerInterval);
                    focusMode.syncTimerState();
                }
            },

            stop: () => {
                // Feature: Ask to complete task on manual stop
                const taskId = document.getElementById('focusTaskSelect').value;
                if(taskId) {
                    const task = state.tasks.find(t => t.id === taskId);
                    if(task && !task.completed) {
                        if(confirm(`Timer stopped. Mark '${task.text}' as completed?`)) {
                            app.toggleTask(taskId);
                        }
                    }
                }
                focusMode.reset();
            },

            complete: () => {
                clearInterval(focusMode.timerInterval);
                AudioEngine.stopBackground();
                
                // SAVE SESSION LOG
                if (focusMode.status === 'focus') {
                    const durationSec = focusMode.totalDuration / 1000;
                    const taskId = document.getElementById('focusTaskSelect').value;
                    const task = state.tasks.find(t => t.id === taskId);
                    
                    const log = { 
                        duration: durationSec, 
                        timestamp: Date.now(),
                        taskId: taskId || null, 
                        taskTitle: task ? task.text : null 
                    };
                    
                    state.focusLogs.push(log);
                    // Critical for sync: save local too
                    localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));
                    
                    if(state.user) {
                         addDoc(collection(db, 'focus_sessions'), { 
                            uid: state.user.uid,
                            ...log
                        }).then(() => console.log("Session Synced")).catch(e => console.error("Sync Fail", e));
                    }
                    
                    if(taskId) app.toggleTask(taskId);
                }

                focusMode.status = 'idle';
                focusMode.updateUI(false);
                document.getElementById('timerDisplay').textContent = "00:00";
                document.getElementById('timerLabel').textContent = "Done";
                
                focusMode.syncTimerState();
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();

                // START ALARM UI
                AudioEngine.playAlarm();
                document.getElementById('alarmModal').style.display = 'flex';

                // Stop automatically after 10 seconds
                if(focusMode.alarmTimeout) clearTimeout(focusMode.alarmTimeout);
                focusMode.alarmTimeout = setTimeout(() => {
                    focusMode.stopAlarmUI();
                }, 10000);
            },

            stopAlarmUI: () => {
                document.getElementById('alarmModal').style.display = 'none';
                AudioEngine.stopAlarm();
                if(focusMode.alarmTimeout) clearTimeout(focusMode.alarmTimeout);
            },

            reset: () => {
                clearInterval(focusMode.timerInterval);
                AudioEngine.stopAlarm();
                document.getElementById('alarmModal').style.display = 'none';
                
                focusMode.status = 'idle';
                focusMode.pausedType = null;
                AudioEngine.stopBackground();
                focusMode.updateUI(false);
                
                let mins = parseInt(document.getElementById('focusDuration').value) || 25;
                const m = mins.toString().padStart(2,'0');
                document.getElementById('timerDisplay').textContent = `${m}:00`;
                document.getElementById('timerLabel').textContent = "Ready";
                focusMode.syncTimerState();
            },

            runLoop: () => {
                clearInterval(focusMode.timerInterval);
                focusMode.timerInterval = setInterval(() => {
                    const now = Date.now();
                    const diff = focusMode.endTime - now;
                    
                    if (diff <= 0) {
                        focusMode.complete();
                    } else {
                        const m = Math.floor(diff / 60000).toString().padStart(2,'0');
                        const s = Math.floor((diff % 60000) / 1000).toString().padStart(2,'0');
                        document.getElementById('timerDisplay').textContent = `${m}:${s}`;
                    }
                }, 1000);
            },

            updateUI: (isRunning) => {
                const circle = document.getElementById('timerCircle');
                const btnPause = document.getElementById('btnPause');
                const btnFocus = document.getElementById('btnStartFocus');
                const btnBreak = document.getElementById('btnStartBreak');

                circle.className = 'timer-circle'; 
                
                if (focusMode.status === 'focus') circle.classList.add('focus-mode', 'timer-active');
                if (focusMode.status === 'break') circle.classList.add('break-mode', 'timer-active');
                if (focusMode.status === 'paused') circle.classList.add('paused', 'timer-active');

                if (focusMode.status === 'idle') {
                    btnFocus.style.display = 'inline-block';
                    btnBreak.style.display = 'inline-block';
                    btnPause.style.display = 'none';
                } else {
                    btnFocus.style.display = focusMode.status === 'focus' ? 'inline-block' : 'none';
                    btnBreak.style.display = focusMode.status === 'break' ? 'inline-block' : 'none';
                    btnPause.style.display = 'inline-block';
                    btnPause.innerHTML = focusMode.status === 'paused' ? '<i class="fas fa-play"></i> Resume' : '<i class="fas fa-pause"></i> Pause';
                    
                    const label = focusMode.status === 'focus' ? "Focusing..." : (focusMode.status === 'break' ? "On Break" : "Paused");
                    document.getElementById('timerLabel').textContent = label;
                }
            },
            
            changeSound: (newSound) => {
                if(focusMode.status === 'focus' || focusMode.status === 'break') {
                    AudioEngine.playBackground(newSound);
                }
            }
        };

        // IDLE TRACKER
        let lastIdleSync = Date.now();

        setInterval(() => {
            if(focusMode.status === 'idle' || focusMode.status === 'paused') {
                state.idleSeconds++;
                const hrs = Math.floor(state.idleSeconds / 3600).toString().padStart(2,'0');
                const mins = Math.floor((state.idleSeconds % 3600) / 60).toString().padStart(2,'0');
                const secs = (state.idleSeconds % 60).toString().padStart(2,'0');
                document.getElementById('idleDisplay').textContent = `${hrs}:${mins}:${secs}`;
                localStorage.setItem('localIdleSeconds', state.idleSeconds);

                if(state.user && Date.now() - lastIdleSync > 10000) {
                    setDoc(doc(db, 'timers', state.user.uid), { 
                        idleSeconds: state.idleSeconds 
                    }, { merge: true });
                    lastIdleSync = Date.now();
                }
            }
        }, 1000);

        // SYNC LISTENER
        onAuthStateChanged(auth, (user) => {
            if(user) {
                state.user = user;
                document.getElementById('authBtn').textContent = "Sign Out";
                document.getElementById('syncDot').style.background = "var(--success)";
                document.getElementById('syncText').textContent = "Cloud Active";
                
                const qTasks = query(collection(db, 'tasks'), where('uid', '==', user.uid));
                onSnapshot(qTasks, (snap) => {
                    state.tasks = snap.docs.map(d => ({id: d.id, ...d.data()}));
                    localStorage.setItem('local_tasks', JSON.stringify(state.tasks));
                    renderTasks();
                    app.renderNotes();
                    if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
                    if(document.getElementById('calendar').classList.contains('active')) renderCalendar();
                    app.syncLeaderboard();
                    app.loadHashtagSelect();
                });

                const qNotes = query(collection(db, 'notes'), where('uid', '==', user.uid));
                onSnapshot(qNotes, (snap) => {
                    state.notes = snap.docs.map(d => ({id: d.id, ...d.data()}));
                    if(document.getElementById('notes').classList.contains('active')) app.renderNotes();
                });

                // Leaderboard Real-time Sync
                const qLeaderboard = query(collection(db, 'leaderboard'), orderBy('score', 'desc'), limit(20));
                onSnapshot(qLeaderboard, (snap) => {
                    if(document.getElementById('community').classList.contains('active')) {
                        app.loadLeaderboard();
                    }
                });

                // User Status Tracking
                const qUserStatus = query(collection(db, 'user_status'), where('uid', '==', user.uid));
                onSnapshot(qUserStatus, (snap) => {
                    if(document.getElementById('community').classList.contains('active')) {
                        app.updateUserStatusList();
                    }
                });

                // Global User Status Listener
                const qGlobalStatus = query(collection(db, 'user_status'));
                onSnapshot(qGlobalStatus, (snap) => {
                    if(document.getElementById('community').classList.contains('active')) {
                        app.updateUserStatusList();
                    }
                });

                // FIXED: Focus Logs Sync with FORCE UPDATE
                const qSessions = query(collection(db, 'focus_sessions'), where('uid', '==', user.uid));
                onSnapshot(qSessions, (snap) => {
                    // Update State
                    state.focusLogs = snap.docs.map(d => d.data());
                    // Critical: Update Local Storage to persist sync across refreshes
                    localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));
                    // Force Render immediately
                    app.renderDashboardCharts();
                    // Load focus tasks after focus logs are loaded
                    app.loadFocusTasks();
                    // Load hashtag select from completed tasks
                    app.loadHashtagSelect();
                });
                
                // Habits Sync
                const qHabits = query(collection(db, 'habits'), where('uid', '==', user.uid));
                onSnapshot(qHabits, (snap) => {
                    state.habits = snap.docs.map(d => ({id: d.id, ...d.data()}));
                    localStorage.setItem('habits', JSON.stringify(state.habits));
                    if(document.getElementById('habits').classList.contains('active')) app.renderHabits();
                });
                
                // Community Chat Sync
                const qChat = query(collection(db, 'community_chat'), orderBy('timestamp', 'desc'), limit(50));
                onSnapshot(qChat, (snap) => {
                    if(document.getElementById('community').classList.contains('active') && state.user) {
                        app.loadCommunity();
                    }
                });
                
                onSnapshot(doc(db, 'timers', user.uid), (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        if(data.idleSeconds > state.idleSeconds) state.idleSeconds = data.idleSeconds;

                        if(data.status && data.updatedAt > (focusMode.lastLocalUpdate || 0)) {
                             if (data.status !== focusMode.status || Math.abs(data.endTime - focusMode.endTime) > 2000) {
                                 focusMode.status = data.status;
                                 focusMode.endTime = data.endTime;
                                 focusMode.remainingAtPause = data.remainingAtPause;
                                 focusMode.totalDuration = data.totalDuration;
                                 focusMode.pausedType = data.pausedType;
                                 
                                 focusMode.updateUI(data.status === 'focus' || data.status === 'break');
                                 if(data.status === 'focus' || data.status === 'break') {
                                     focusMode.runLoop();
                                 } else {
                                     clearInterval(focusMode.timerInterval);
                                     if(data.status === 'idle') {
                                         document.getElementById('timerDisplay').textContent = "00:00";
                                     } else if (data.status === 'paused') {
                                         const diff = data.remainingAtPause;
                                         const m = Math.floor(diff / 60000).toString().padStart(2,'0');
                                         const s = Math.floor((diff % 60000) / 1000).toString().padStart(2,'0');
                                         document.getElementById('timerDisplay').textContent = `${m}:${s}`;
                                     }
                                 }
                             }
                        }
                    }
                });

            } else {
                state.user = null;
                document.getElementById('authBtn').textContent = "Sign In";
                document.getElementById('syncDot').style.background = "var(--warning)";
                document.getElementById('syncText').textContent = "Offline";
                state.tasks = JSON.parse(localStorage.getItem('local_tasks')) || [];
                state.notes = JSON.parse(localStorage.getItem('local_notes')) || [];
                state.focusLogs = JSON.parse(localStorage.getItem('focusLogs')) || [];
                state.habits = JSON.parse(localStorage.getItem('habits')) || [];
                renderTasks();
                app.renderNotes();
                if(document.getElementById('habits').classList.contains('active')) app.renderHabits();
                if(document.getElementById('community').classList.contains('active')) app.loadCommunity();
                // Load hashtag select from completed tasks
                app.loadHashtagSelect();
            }
        });

        // RENDERING
        function renderTasks() {
            const list = document.getElementById('taskList');
            list.innerHTML = "";
            const filter = state.taskFilter; 
            let visibleTasks = [];
            
            if(filter === 'completed') {
                visibleTasks = state.tasks.filter(t => t.completed);
            } else if(filter === 'overdue') {
                const today = new Date().toISOString().split('T')[0];
                visibleTasks = state.tasks.filter(t => !t.completed && t.date < today);
            } else { // active
                const today = new Date().toISOString().split('T')[0];
                visibleTasks = state.tasks.filter(t => !t.completed && t.date >= today);
            }
            
            // Group tasks by date
            const tasksByDate = {};
            visibleTasks.forEach(task => {
                if(!tasksByDate[task.date]) {
                    tasksByDate[task.date] = [];
                }
                tasksByDate[task.date].push(task);
            });
            
            // Sort dates in descending order
            const sortedDates = Object.keys(tasksByDate).sort((a, b) => new Date(b) - new Date(a));
            
            sortedDates.forEach(date => {
                const dateObj = new Date(date);
                const dateStr = dateObj.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                const isToday = date === new Date().toISOString().split('T')[0];
                const isOverdue = new Date(date) < new Date() && !isToday;
                const dateId = 'date-' + date.replace(/[^a-zA-Z0-9]/g, '-');
                const isCollapsed = localStorage.getItem('collapsed-' + dateId) === 'true';
                
                // Add date header with expand/collapse
                const dateHeader = document.createElement('div');
                let borderColor = 'var(--accent)';
                if(filter === 'overdue') borderColor = 'var(--danger)';
                else if(isOverdue) borderColor = 'var(--warning)';
                
                dateHeader.style.cssText = `margin: 20px 0 10px 0; padding: 10px; background: var(--bg-card); border-radius: 8px; border-left: 4px solid ${borderColor}; cursor: pointer;`;
                dateHeader.innerHTML = `
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <div>
                            <div style="font-weight: 600; color: var(--text-main); font-size: 14px;">
                                ${isToday ? '(Today)' : ''} ${isOverdue ? '(Overdue)' : ''} ${dateStr}
                            </div>
                            <div style="font-size: 12px; color: var(--text-muted); margin-top: 2px;">
                                ${tasksByDate[date].length} task${tasksByDate[date].length !== 1 ? 's' : ''}
                            </div>
                        </div>
                        <i class="fas fa-chevron-${isCollapsed ? 'right' : 'down'}" style="color: var(--text-muted); transition: transform 0.2s;"></i>
                    </div>
                `;
                
                dateHeader.onclick = () => {
                    const content = document.getElementById('content-' + dateId);
                    const icon = dateHeader.querySelector('i');
                    
                    if(isCollapsed) {
                        content.style.display = 'block';
                        icon.className = 'fas fa-chevron-down';
                        localStorage.removeItem('collapsed-' + dateId);
                    } else {
                        content.style.display = 'none';
                        icon.className = 'fas fa-chevron-right';
                        localStorage.setItem('collapsed-' + dateId, 'true');
                    }
                };
                
                list.appendChild(dateHeader);
                
                // Add tasks for this date in collapsible container
                const contentContainer = document.createElement('div');
                contentContainer.id = 'content-' + dateId;
                contentContainer.style.display = isCollapsed ? 'none' : 'block';
                
                tasksByDate[date].forEach(task => {
                    const subsHtml = (task.subtasks||[]).map(s => {
                        const descHtml = s.description ? `<div style="font-size:11px; color:var(--text-muted); margin-left:20px; font-style:italic; cursor:pointer;" onclick="app.editSubtaskDescription('${task.id}', '${s.id}')">${s.description}</div>` : '';
                        return `<div class="subtask-row">
                            <input type="checkbox" ${s.completed ? 'checked' : ''} onchange="app.toggleSubtask('${task.id}', '${s.id}')">
                            <span style="text-decoration:${s.completed?'line-through':'none'}; opacity:${s.completed?0.5:1}; flex:1; color:var(--text-muted);">${s.text}</span>
                            ${descHtml}
                            <button class="btn btn-icon btn-danger" style="width:20px;height:20px;padding:0;font-size:10px;" onclick="app.deleteSubtask('${task.id}', '${s.id}')"><i class="fas fa-times"></i></button>
                        </div>`;
                    }).join('');
                    const tagsHtml = (task.tags||[]).map(t=>`<span class="tag">#${t}</span>`).join('');
                    const descHtml = task.description ? `<div style="font-size:12px; color:var(--text-muted); margin:5px 0; padding:8px; background:var(--bg-body); border-radius:6px; border-left:3px solid var(--accent); cursor:pointer;" onclick="app.editTaskDescription('${task.id}')">${task.description}</div>` : '';
                    const html = `<div class="task-card priority-${task.priority}"><div class="task-header"><input type="checkbox" class="checkbox" ${task.completed ? 'checked' : ''} onchange="app.toggleTask('${task.id}')"><div class="task-content"><div class="task-title" style="text-decoration: ${task.completed ? 'line-through' : 'none'}">${task.text.replace(/#\w+/g,'')} ${tagsHtml}</div>${descHtml}<div class="task-meta"><i class="far fa-calendar"></i> ${task.date} • ${task.priority.toUpperCase()}</div></div><div style="display:flex;gap:5px;"><button class="btn btn-icon" onclick="app.focusOnTask('${task.id}')"><i class="fas fa-stopwatch"></i></button><button class="btn btn-icon" onclick="app.startEdit('${task.id}')"><i class="fas fa-pencil"></i></button><button class="btn btn-icon btn-danger" onclick="app.deleteTask('${task.id}')"><i class="fas fa-trash"></i></button></div></div><div class="subtasks">${subsHtml}<div class="subtask-row"><input id="sub-input-${task.id}" placeholder="+ Subtask" style="background:transparent;border:none;color:var(--text-muted);width:100%;outline:none;font-size:13px;" onkeydown="if(event.key==='Enter') app.addSubtask('${task.id}')"></div><div class="subtask-row"><button class="btn btn-icon" style="padding: 4px 8px; font-size: 11px;" onclick="app.addSubtaskWithDesc('${task.id}')" title="Add with description">+Desc</button></div></div></div>`;
                    contentContainer.insertAdjacentHTML('beforeend', html);
                });
                
                list.appendChild(contentContainer);
            });
            
            if(visibleTasks.length === 0) {
                let emptyMessage = `No ${filter} tasks found.`;
                if(filter === 'overdue') emptyMessage = 'No overdue tasks. Great job staying on track!';
                if(filter === 'active') emptyMessage = 'No active tasks for today or future dates.';
                if(filter === 'completed') emptyMessage = 'No completed tasks yet.';
                list.innerHTML = `<div style="text-align:center;color:var(--text-muted);margin-top:20px;">${emptyMessage}</div>`;
            }
        }

        function renderCalendar() {
            const grid = document.getElementById('calGrid');
            grid.innerHTML = `<div class="cal-day-header">Sun</div><div class="cal-day-header">Mon</div><div class="cal-day-header">Tue</div><div class="cal-day-header">Wed</div><div class="cal-day-header">Thu</div><div class="cal-day-header">Fri</div><div class="cal-day-header">Sat</div>`;
            const year = state.currentDate.getFullYear();
            const month = state.currentDate.getMonth();
            document.getElementById('calMonthYear').textContent = new Date(year, month).toLocaleString('default', { month: 'long', year: 'numeric' });
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            for(let i=0; i<firstDay; i++) grid.insertAdjacentHTML('beforeend', `<div></div>`);
            for(let d=1; d<=daysInMonth; d++) {
                const dateStr = `${year}-${String(month+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
                const isToday = dateStr === new Date().toISOString().split('T')[0];
                const dayTasks = state.tasks.filter(t => t.date === dateStr);
                const dots = dayTasks.map(t => `<div class="cal-task-dot ${t.completed?'done':''}">${t.text}</div>`).join('');
                grid.insertAdjacentHTML('beforeend', `<div class="cal-cell ${isToday ? 'today' : ''}" data-date="${dateStr}" onclick="app.selectDate('${dateStr}')"><div class="cal-date">${d}</div>${dots}</div>`);
            }
        }

        function renderSuggestions() {
            document.getElementById('suggestionsBox').innerHTML = state.history.map(h => `<div class="suggestion-chip" onclick="app.addTask('${h}')">${h} <span onclick="event.stopPropagation();app.removeSuggestion('${h}')">×</span></div>`).join('');
        }
        window.app.removeSuggestion = (t) => { state.history = state.history.filter(h => h !== t); localStorage.setItem('taskHistory', JSON.stringify(state.history)); renderSuggestions(); };

        app.init();
        renderSuggestions();
    </script>
    <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(reg => console.log('Service Worker registered!', reg))
        .catch(err => console.log('Registration failed!', err));
    });
  }
</script> 
</body>
</html>
