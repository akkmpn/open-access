<!DOCTYPE html>
<html lang="en" data-theme="dark" data-design="default">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Enterprise TaskPro - v8.0 (Live Cloud Sync)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Playfair+Display:wght@400;700&family=Roboto+Mono:wght@400;700&family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <style>
        /* ==================== 1. CORE VARIABLES ==================== */
        :root {
            --bg-body: #0f172a;
            --bg-sidebar: #1e293b;
            --bg-card: #334155;
            --bg-input: #1e293b;
            --bg-hover: rgba(255,255,255,0.05);
            --accent: #208084;
            --accent-hover: #2ba8ad;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --border: #475569;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --streak-fire: #f97316;
            --streak-target: #8b5cf6;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --radius: 12px;
            --font-main: 'Inter', sans-serif;
            --border-width: 1px;
            --sidebar-width: 260px;
        }

        [data-theme="light"] {
            --bg-body: #f1f5f9;
            --bg-sidebar: #ffffff;
            --bg-card: #ffffff;
            --bg-input: #f8fafc;
            --bg-hover: #f1f5f9;
            --text-main: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: var(--font-main);
            background: var(--bg-body);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            transition: background 0.3s, color 0.3s;
        }

        /* ==================== SIDEBAR ==================== */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-sidebar);
            border-right: var(--border-width) solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            transition: transform 0.3s ease;
            z-index: 50;
            flex-shrink: 0;
        }
        
        .logo { font-size: 20px; font-weight: 800; color: var(--text-main); margin-bottom: 30px; display: flex; align-items: center; gap: 10px; }
        .logo i { color: var(--accent); }

        .nav-link {
            display: flex; align-items: center; gap: 12px; padding: 12px 15px;
            color: var(--text-muted); text-decoration: none; border-radius: var(--radius);
            margin-bottom: 5px; transition: 0.2s; cursor: pointer; font-size: 14px; font-weight: 500;
            border: var(--border-width) solid transparent; background: none; width: 100%; text-align: left;
            font-family: var(--font-main);
        }
        .nav-link:hover { background: var(--bg-hover); color: var(--text-main); }
        .nav-link.active { background: var(--accent); color: white; box-shadow: var(--shadow); border-color: var(--accent); }

        .sidebar-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 40; display: none; backdrop-filter: blur(2px); }

        /* ==================== MAIN CONTENT ==================== */
        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; width: 100%; }

        /* HEADER */
        .header {
            height: 70px;
            border-bottom: var(--border-width) solid var(--border);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; background: var(--bg-body); transition: background 0.3s; flex-shrink: 0;
        }
        
        .weather-widget { font-size: 11px; display: flex; flex-direction: column; text-align: right; color: var(--text-muted); margin-right: 15px; }
        .weather-info { display: flex; align-items: center; gap: 6px; color: var(--text-main); font-weight: 600; }

        .menu-btn { display: none; background: none; border: none; color: var(--text-main); font-size: 20px; cursor: pointer; padding: 5px; }
        .header-actions { display: flex; align-items: center; gap: 10px; }
        .icon-btn-header {
            background: var(--bg-card); border: var(--border-width) solid var(--border); color: var(--text-muted);
            width: 36px; height: 36px; border-radius: var(--radius); display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s; box-shadow: var(--shadow);
        }
        .icon-btn-header:hover { color: var(--accent); border-color: var(--accent); }

        /* VIEWS */
        .view-container { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 20px; display: none; animation: fadeIn 0.3s ease; }
        .view-container.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* ==================== COMPONENTS ==================== */
        .btn {
            padding: 10px 16px; border-radius: var(--radius); border: var(--border-width) solid transparent;
            font-weight: 600; cursor: pointer; transition: 0.2s; font-size: 13px;
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
            font-family: var(--font-main); box-shadow: var(--shadow);
        }
        .btn-primary { background: var(--accent); color: white; border-color: var(--accent); }
        .btn-primary:hover { opacity: 0.9; filter: brightness(110%); }
        .btn-secondary { background: var(--bg-card); color: var(--text-main); border-color: var(--border); }
        .btn-secondary:hover { border-color: var(--text-muted); }
        .btn-icon { padding: 8px; border-radius: 50%; width: 36px; height: 36px; }
        .btn-danger { color: var(--danger); background: rgba(239, 68, 68, 0.1); }
        .btn-danger:hover { background: rgba(239, 68, 68, 0.2); }

        .input-group {
            background: var(--bg-card); padding: 15px; border-radius: var(--radius);
            display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px;
            border: var(--border-width) solid var(--border); align-items: center; box-shadow: var(--shadow);
        }
        .main-input { background: transparent; border: none; color: var(--text-main); padding: 10px; flex: 1; min-width: 200px; outline: none; font-size: 16px; font-family: var(--font-main); }
        .date-input, .select-input { background: var(--bg-body); border: var(--border-width) solid var(--border); color: var(--text-main); padding: 10px 12px; border-radius: var(--radius); outline: none; font-size: 14px; font-family: var(--font-main); }

        /* Task Cards */
        .task-list { display: flex; flex-direction: column; gap: 12px; padding-bottom: 80px; }
        .task-card {
            background: var(--bg-card); border-radius: var(--radius); padding: 16px;
            border: var(--border-width) solid var(--border); border-left: 4px solid var(--border);
            transition: all 0.2s; box-shadow: var(--shadow); position: relative;
        }
        .task-header { display: flex; align-items: flex-start; gap: 15px; }
        .checkbox { appearance: none; width: 24px; height: 24px; border: 2px solid var(--text-muted); border-radius: 6px; cursor: pointer; flex-shrink: 0; margin-top: 2px; position: relative; }
        .checkbox:checked { background: var(--accent); border-color: var(--accent); }
        .checkbox:checked::after { content: '✓'; position: absolute; color: white; font-size: 14px; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        .task-content { flex: 1; min-width: 0; }
        .task-title { font-size: 15px; margin-bottom: 5px; line-height: 1.4; color: var(--text-main); word-wrap: break-word; }
        .task-meta { display: flex; flex-wrap: wrap; gap: 10px; font-size: 12px; color: var(--text-muted); align-items: center; }
        .tag { padding: 2px 8px; border-radius: 10px; background: rgba(32, 128, 132, 0.15); color: var(--accent); font-size: 11px; font-weight: 600; white-space: nowrap;}
        
        .priority-high { border-left-color: var(--danger); }
        .priority-medium { border-left-color: var(--warning); }
        .priority-low { border-left-color: var(--success); }

        .subtasks { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border); display: flex; flex-direction: column; gap: 10px; }
        .subtask-row { display: flex; align-items: center; gap: 12px; font-size: 14px; padding-left: 5px; }

        .suggestions { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 10px; margin-bottom: 10px; }
        .suggestion-chip { padding: 6px 14px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 20px; font-size: 12px; cursor: pointer; white-space: nowrap; transition: 0.2s; display: flex; align-items: center; gap: 8px; color: var(--text-muted); }
        
        /* Calendar */
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; margin-top: 20px; }
        .cal-day-header { text-align: center; font-size: 11px; color: var(--text-muted); padding-bottom: 5px; }
        .cal-cell { background: var(--bg-card); border-radius: var(--radius); min-height: 80px; padding: 5px; border: 1px solid var(--border); position: relative; overflow: hidden; cursor: pointer; transition: 0.2s; }
        .cal-cell:hover { border-color: var(--accent); }
        .cal-cell.today { border-color: var(--accent); background: rgba(32, 128, 132, 0.05); }
        .cal-cell.selected { border: 2px solid var(--text-main); }
        .cal-date { font-size: 11px; font-weight: bold; margin-bottom: 3px; color: var(--text-main); }
        .cal-task-dot { width: 100%; margin-bottom: 2px; padding: 2px; border-radius: 3px; font-size: 9px; background: var(--bg-input); color: var(--text-main); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cal-task-dot.done { text-decoration: line-through; opacity: 0.5; }
        
        /* Mobile List for Calendar */
        .cal-mobile-list { margin-top: 20px; padding: 15px; background: var(--bg-card); border-radius: var(--radius); border: 1px solid var(--border); display: none; }
        
        /* Focus Timer */
        .timer-container { text-align:center; max-width:500px; margin:0 auto; }
        .timer-circle { 
            width: 240px; height: 240px; border-radius: 50%; border: 8px solid var(--bg-card); 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            margin: 20px auto; position: relative; 
            background: radial-gradient(circle, var(--bg-sidebar) 0%, var(--bg-body) 100%); 
            box-shadow: var(--shadow); color: var(--text-main); transition: 0.3s; 
        }
        .timer-time { font-size: 48px; font-weight: 700; line-height: 1; }
        .timer-label { font-size: 14px; text-transform: uppercase; color: var(--text-muted); margin-top: 5px; letter-spacing: 1px;}
        
        /* Visual Glows */
        .timer-active.focus-mode { 
            border-color: var(--accent); 
            box-shadow: 0 0 40px rgba(32, 128, 132, 0.5), inset 0 0 15px rgba(32, 128, 132, 0.2); 
        }
        .timer-active.break-mode { 
            border-color: var(--success); 
            box-shadow: 0 0 40px rgba(16, 185, 129, 0.5), inset 0 0 15px rgba(16, 185, 129, 0.2); 
        }
        .timer-active.paused { 
            border-color: var(--warning);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
            animation: pulse 2s infinite; 
            opacity: 0.9; 
        }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        .idle-tracker {
            margin-top: 30px; padding: 15px; border-top: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }

        /* Leaderboard */
        .leaderboard-table { width: 100%; border-collapse: collapse; margin-top: 10px; min-width: 300px; }
        .leaderboard-table th { text-align: left; padding: 10px; color: var(--text-muted); font-size: 12px; border-bottom: 1px solid var(--border); }
        .leaderboard-table td { padding: 12px 10px; border-bottom: 1px solid var(--border); font-size: 14px; }
        .rank-badge { width: 24px; height: 24px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 11px; font-weight: bold; margin-right: 10px; }
        .rank-1 { background: #fbbf24; color: #78350f; } .rank-2 { background: #94a3b8; color: #0f172a; } .rank-3 { background: #b45309; color: #fffbeb; }

        /* Notes & Chat */
        .note-card { background: var(--bg-card); border: var(--border-width) solid var(--border); border-radius: var(--radius); padding: 20px; margin-bottom: 15px; box-shadow: var(--shadow); display: flex; flex-direction: column; }
        .note-header-actions { display: flex; justify-content: flex-end; gap: 8px; margin-bottom: 10px; }
        .note-action-btn { background: var(--bg-body); border: 1px solid var(--border); color: var(--text-muted); width: 30px; height: 30px; border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; }
        .note-action-btn:hover { color: var(--accent); border-color: var(--accent); background: var(--bg-hover); }
        .note-content { font-family: 'Playfair Display', serif; font-size: 18px; line-height: 1.6; color: var(--text-main); white-space: pre-wrap; flex: 1; }
        .note-date { font-family: var(--font-main); font-size: 11px; color: var(--text-muted); margin-top: 15px; text-align: right; border-top: 1px solid var(--border); padding-top: 10px; }
        
        .chat-layout { display: flex; height: 500px; background: var(--bg-body); border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden; margin-top: 20px; }
        .chat-main { flex: 1; display: flex; flex-direction: column; border-right: 1px solid var(--border); }
        .chat-messages { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        .chat-input-area { padding: 10px; background: var(--bg-card); border-top: 1px solid var(--border); display: flex; gap: 10px; }
        .chat-sidebar-panel { width: 200px; background: var(--bg-sidebar); padding: 10px; overflow-y: auto; display: none; }
        @media(min-width: 768px) { .chat-sidebar-panel { display: block; } }
        .chat-msg { max-width: 80%; padding: 8px 12px; border-radius: 12px; font-size: 13px; line-height: 1.4; word-wrap: break-word; }
        .chat-msg.them { background: var(--bg-card); align-self: flex-start; border-bottom-left-radius: 0; border: 1px solid var(--border); }
        .chat-msg.me { background: var(--accent); color: white; align-self: flex-end; border-bottom-right-radius: 0; }

        @media (max-width: 768px) {
            .sidebar { position: fixed; top: 0; left: 0; bottom: 0; transform: translateX(-100%); box-shadow: 5px 0 15px rgba(0,0,0,0.5); }
            .sidebar.open { transform: translateX(0); }
            .menu-btn { display: block; }
            .view-container { padding: 15px; }
            .input-group { flex-direction: column; align-items: stretch; }
            .date-input, .select-input, .btn { width: 100%; }
            .timer-circle { width: 200px; height: 200px; border-width: 6px; }
            .timer-time { font-size: 40px; }
            .cal-cell { min-height: 50px; }
            .cal-task-dot { display: none; }
            .cal-mobile-list { display: block; }
            .chat-layout { height: 100%; flex-direction: column; }
            .chat-sidebar-panel { width: 100%; height: 100px; border-bottom: 1px solid var(--border); display: block; }
        }
        
        /* New Focus Stats */
        .focus-stat-container { display:flex; align-items:center; justify-content:space-between; width:100%; gap:20px; flex-wrap:wrap;}
        .focus-stat-box { flex:1; min-width:200px; background:var(--bg-body); border-radius:10px; padding:15px; border:1px solid var(--border); display:flex; flex-direction:column; gap:5px;}
        .progress-bar { width:100%; height:8px; background:var(--bg-body); border-radius:4px; overflow:hidden; margin-top:5px; border:1px solid var(--border); }
        .progress-fill { height:100%; background:var(--accent); border-radius:4px; width:0%; transition: width 0.5s ease; }

        /* Task Focus Row */
        .focus-task-row { display:flex; justify-content:space-between; align-items:center; font-size:12px; padding:6px 0; border-bottom:1px solid var(--border); }
        .focus-task-row:last-child { border-bottom:none; }
        .focus-task-name { color:var(--text-main); font-weight:500; flex: 1; }
        .focus-task-time { color:var(--text-muted); font-family:monospace; margin-right: 10px; }
        .focus-task-actions { display: flex; gap: 5px; opacity: 0.6; transition: 0.2s; }
        .focus-task-row:hover .focus-task-actions { opacity: 1; }
        .focus-icon-btn { cursor: pointer; color: var(--text-muted); font-size: 11px; padding: 2px; }
        .focus-icon-btn:hover { color: var(--accent); }

        /* ALARM MODAL */
        #alarmModal { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:2000; display:none; align-items:center; justify-content:center; backdrop-filter: blur(10px); }
        .alarm-content { background: var(--bg-card); padding: 40px; border-radius: 20px; text-align: center; border: 2px solid var(--accent); box-shadow: 0 0 50px rgba(32, 128, 132, 0.4); animation: pulseAlarm 1s infinite; max-width: 90%; }
        @keyframes pulseAlarm { 0% { transform: scale(1); box-shadow: 0 0 30px rgba(32, 128, 132, 0.4); } 50% { transform: scale(1.02); box-shadow: 0 0 60px rgba(32, 128, 132, 0.7); } 100% { transform: scale(1); box-shadow: 0 0 30px rgba(32, 128, 132, 0.4); } }
    </style>
    <style id="dynamic-theme-style"></style>
</head>
<body>

    <div class="sidebar-overlay" id="sidebarOverlay" onclick="app.toggleSidebar()"></div>

    <div id="alarmModal">
        <div class="alarm-content">
            <i class="fas fa-bell" style="font-size: 60px; color: var(--accent); margin-bottom: 20px;"></i>
            <h1 style="color: var(--text-main); margin-bottom: 10px;">Time is Up!</h1>
            <p style="color: var(--text-muted); margin-bottom: 30px; font-size: 16px;">Good job. Take a breath.</p>
            <button class="btn btn-primary" style="padding: 15px 40px; font-size: 18px;" onclick="focusMode.stopAlarmUI()">Stop Alarm</button>
        </div>
    </div>

    <aside class="sidebar" id="sidebar">
        <div class="logo">
            <i class="fas fa-bolt"></i> TaskPro 8.0
            <button class="btn btn-icon" style="margin-left:auto; background:transparent; display:none;" onclick="app.toggleSidebar()" id="closeSidebarBtn"><i class="fas fa-times"></i></button>
        </div>
        
        <nav>
            <button class="nav-link active" onclick="app.switchTab('dashboard')"><i class="fas fa-chart-pie"></i> Dashboard</button>
            <button class="nav-link" onclick="app.switchTab('tasks')">
                <i class="fas fa-tasks"></i> My Tasks
                <span id="badge" style="margin-left:auto; background:var(--accent); padding:2px 8px; border-radius:10px; font-size:10px; color: white;">0</span>
            </button>
            <button class="nav-link" onclick="app.switchTab('notes')"><i class="fas fa-sticky-note"></i> My Notes</button>
            <button class="nav-link" onclick="app.switchTab('calendar')"><i class="far fa-calendar-alt"></i> Calendar</button>
            <button class="nav-link" onclick="app.switchTab('focus')"><i class="fas fa-stopwatch"></i> Pomodoro & Idle</button>
            <button class="nav-link" onclick="app.switchTab('community')"><i class="fas fa-users"></i> Community</button>
        </nav>

        <div style="margin-top: auto;">
            <button class="nav-link" onclick="app.saveLifetime(true)">
                <i class="fas fa-save"></i> Force Save
            </button>
            <button class="nav-link" onclick="app.backupData()">
                <i class="fas fa-download"></i> Checkpoint
            </button>
            <button class="nav-link" onclick="app.resetAllData()" style="color:var(--danger);">
                <i class="fas fa-trash-alt"></i> Reset All Data
            </button>

            <button class="nav-link" onclick="document.getElementById('importInput').click()">
                <i class="fas fa-upload"></i> Restore
            </button>
            <input type="file" id="importInput" style="display:none" onchange="app.restoreData(this)">
            <div class="nav-link" style="cursor: default; opacity: 0.7; font-size:12px;">
                <i class="fas fa-cloud"></i> <span id="syncText">Offline</span>
            </div>
            <button class="btn btn-secondary" style="width:100%; margin-top:10px;" id="authBtn" onclick="app.toggleAuth()">Sign In</button>
        </div>
    </aside>

    <main class="main">
        <header class="header">
            <div style="display:flex; align-items:center; gap:10px;">
                <button class="menu-btn" onclick="app.toggleSidebar()"><i class="fas fa-bars"></i></button>
                <h2 id="pageTitle" style="color:var(--text-main); font-size: 18px;">Dashboard</h2>
            </div>

            <div style="display:flex; align-items:center;">
                <div class="weather-widget">
                    <div id="clockDisplay" style="margin-bottom:2px;">--:--</div>
                    <div class="weather-info" id="weatherDisplay">
                        <i class="fas fa-cloud"></i> <span>--°C</span>
                    </div>
                </div>

                <div class="header-actions">
                    <button class="btn btn-primary" style="font-size:11px; padding: 8px 12px;" onclick="app.generateRandomDesign()" title="Remix UI">
                        <i class="fas fa-magic"></i>
                    </button>
                    <button class="icon-btn-header" onclick="app.toggleTheme()"><i class="fas fa-moon" id="themeIcon"></i></button>
                    <div style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--warning);" id="syncDot"></div>
                    </div>
                </div>
            </div>
        </header>

        <div id="dashboard" class="view-container active">
            <div style="display:flex; gap:10px; margin-bottom:20px; overflow-x:auto;">
                <select id="dashFilterTime" class="select-input" style="width:auto;" onchange="app.renderDashboardCharts()">
                    <option value="all">All Time</option>
                    <option value="daily">Today</option>
                    <option value="weekly">This Week</option>
                    <option value="monthly">This Month</option>
                    <option value="yearly">This Year</option>
                </select>
                <select id="dashFilterTag" class="select-input" style="width:auto;" onchange="app.renderDashboardCharts()">
                    <option value="all">All Tags</option>
                </select>
            </div>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; margin-bottom: 30px;">
                <div class="task-card" style="text-align:center; padding: 20px 10px;">
                    <div style="font-size:28px; font-weight:700; color:var(--accent);" id="dashTotal">0</div>
                    <div style="color:var(--text-muted); font-size:11px; margin-top:5px;">TOTAL (INC. SUBS)</div>
                </div>
                <div class="task-card" style="text-align:center; padding: 20px 10px;">
                    <div style="font-size:28px; font-weight:700; color:var(--success);" id="dashDone">0</div>
                    <div style="color:var(--text-muted); font-size:11px; margin-top:5px;">COMPLETED</div>
                </div>
                <div class="task-card" style="text-align:center; padding: 20px 10px;">
                    <div style="font-size:28px; font-weight:700; color:var(--warning);" id="dashPending">0</div>
                    <div style="color:var(--text-muted); font-size:11px; margin-top:5px;">PENDING</div>
                </div>
                <div class="task-card" style="text-align:center; padding: 20px 10px;">
                    <div style="font-size:28px; font-weight:700; color:var(--streak-fire); display:flex; align-items:center; justify-content:center; gap:8px;">
                        <span id="streakCount">0</span>
                        <i class="fas fa-fire" id="streakIcon" style="font-size:20px; opacity:0.3; transition:0.3s;"></i>
                    </div>
                    <div style="color:var(--text-muted); font-size:11px; margin-top:5px;">DAILY STREAK</div>
                </div>
                <div class="task-card" style="text-align:center; padding: 20px 10px; border-left-color: var(--streak-target);">
                    <div style="font-size:28px; font-weight:700; color:var(--streak-target); display:flex; align-items:center; justify-content:center; gap:8px;">
                        <span id="subStreakCount">0</span>
                        <i class="fas fa-crosshairs" style="font-size:18px;"></i>
                    </div>
                    <div style="margin-top:5px; padding:0 10px;">
                        <select id="subStreakSelect" class="select-input" style="width:100%; font-size:11px; padding:5px; background: var(--bg-body);" onchange="app.updateSubStreak()">
                            <option value="">Select Task...</option>
                        </select>
                    </div>
                    <div style="font-size:9px; color:var(--text-muted); margin-top:5px;">TASK SPECIFIC STREAK</div>
                </div>
            </div>

            <div class="task-card" style="margin-bottom:20px; border-left-color:var(--accent);">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <h3 style="color:var(--text-main); font-size:16px;">Focus Goal & Analytics</h3>
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span style="font-size:12px; color:var(--text-muted);">Daily Goal:</span>
                        <input type="number" id="dailyGoalInput" class="select-input" style="width:60px; padding:4px;" value="3" onchange="app.setDailyGoal(this.value)">
                        <span style="font-size:12px; color:var(--text-muted);">hrs</span>
                    </div>
                </div>
                <div class="focus-stat-container">
                    <div class="focus-stat-box">
                        <div style="display:flex; align-items:center; justify-content:space-between; font-size:11px; color:var(--text-muted); text-transform:uppercase;">
                            <span>Time Focused (<span id="focusTimeLabel">Today</span>)</span>
                            <button class="btn btn-icon btn-danger" style="width:20px;height:20px;padding:0;font-size:10px; opacity:0.7;" onclick="app.resetFocusData()" title="Reset All Focus History"><i class="fas fa-trash"></i></button>
                        </div>
                        <div style="font-size:24px; font-weight:700; color:var(--text-main); margin-top:5px;" id="focusTimeDisplay">0h 0m</div>
                    </div>
                    <div class="focus-stat-box" style="flex:2;">
                         <div style="display:flex; justify-content:space-between; font-size:11px; color:var(--text-muted); margin-bottom:2px;">
                            <span>Goal Progress</span>
                            <span id="goalPercentDisplay">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="goalProgressBar"></div>
                        </div>
                        <div style="font-size:10px; color:var(--text-muted); margin-top:5px;">Target: <span id="goalTargetDisplay">3h</span></div>
                    </div>
                </div>
                
                <div style="margin-top:15px; border-top:1px solid var(--border); padding-top:15px;">
                    <h4 style="font-size:12px; color:var(--text-muted); margin-bottom:10px; text-transform:uppercase;">Top Focused Tasks</h4>
                    <div id="taskFocusList" style="max-height:150px; overflow-y:auto; padding-right:5px;">
                        <div style="font-size:12px; color:var(--text-muted); font-style:italic;">No specific task data yet.</div>
                    </div>
                </div>
            </div>

            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap:20px;">
                <div class="task-card">
                    <h3 style="margin-bottom:15px; color:var(--text-main); font-size:16px;">Productivity Trend</h3>
                    <div style="height: 250px; position: relative;"><canvas id="mainChart"></canvas></div>
                </div>
                <div class="task-card">
                    <h3 style="margin-bottom:15px; color:var(--text-main); font-size:16px;">Hashtag Analysis</h3>
                    <div style="height: 250px; position: relative;"><canvas id="tagChart"></canvas></div>
                </div>
            </div>
        </div>

        <div id="tasks" class="view-container">
            <div class="suggestions" id="suggestionsBox"></div>
            <div class="input-group">
                <input type="hidden" id="editTaskId">
                <input type="text" id="taskInput" class="main-input" placeholder="Add a task... (Use #tag)">
                <input type="date" id="dateInput" class="date-input">
                <select id="prioInput" class="select-input" style="width: auto;">
                    <option value="medium">Medium</option>
                    <option value="high">High</option>
                    <option value="low">Low</option>
                </select>
                <button class="btn btn-primary" id="addUpdateBtn" onclick="app.handleTaskSubmit()"><i class="fas fa-plus"></i> Add</button>
                <button class="btn btn-secondary" id="cancelEditBtn" style="display:none;" onclick="app.cancelEdit()">Cancel</button>
            </div>
            <div style="margin-bottom:15px; display:flex; gap:10px;">
                <button class="btn btn-secondary" onclick="app.setTaskFilter('active')" id="filterActive">Active</button>
                <button class="btn btn-secondary" onclick="app.setTaskFilter('completed')" id="filterCompleted">Completed</button>
            </div>
            <div id="taskList" class="task-list"></div>
        </div>

        <div id="notes" class="view-container">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                <div>
                    <h2 style="color:var(--text-main);">My Notes & Quotes</h2>
                    <p style="color:var(--text-muted); font-size:13px;">Online Storage. Your thoughts, safe in the cloud.</p>
                </div>
                <div style="font-size:30px; color:var(--accent); opacity:0.5;"><i class="fas fa-feather-alt"></i></div>
            </div>
            <div class="input-group" style="align-items:flex-start;">
                <textarea id="noteInput" class="main-input" rows="3" style="resize:vertical; min-height:80px;" placeholder="Write a quote, thought, or memo..."></textarea>
                <button class="btn btn-primary" style="height:fit-content;" onclick="app.addNote()">Save Note</button>
            </div>
            <div id="notesList" style="display: flex; flex-direction: column; gap: 15px;"></div>
        </div>

        <div id="calendar" class="view-container">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h2 id="calMonthYear" style="color:var(--text-main); font-size:18px;"></h2>
                <div style="display:flex; gap:5px;">
                    <button class="btn btn-secondary btn-icon" onclick="app.changeMonth(-1)"><i class="fas fa-chevron-left"></i></button>
                    <button class="btn btn-secondary btn-icon" onclick="app.changeMonth(1)"><i class="fas fa-chevron-right"></i></button>
                </div>
            </div>
            <div class="calendar-grid" id="calGrid"></div>
            <div class="cal-mobile-list" id="calMobileView">
                <h4 style="margin-bottom:10px; color:var(--text-muted);" id="calSelectedDate">Select a date</h4>
                <div id="calSelectedTasks"></div>
            </div>
        </div>

        <div id="focus" class="view-container">
            <div class="timer-container">
                <h2 style="color:var(--text-main); margin-bottom: 20px;">Pomodoro & Idle Tracker</h2>
                
                <div style="margin-bottom: 20px;">
                    <label style="display:block; font-size:12px; color:var(--text-muted); margin-bottom:5px;">Link to Task (Optional)</label>
                    <select id="focusTaskSelect" class="select-input" style="width:100%; max-width:300px;">
                        <option value="">-- No specific task --</option>
                    </select>
                </div>

                <div style="display:flex; justify-content:center; gap:10px; margin-bottom:20px; flex-wrap:wrap;">
                    <div style="display:flex; flex-direction:column; gap:5px; align-items:flex-start;">
                        <span style="font-size:11px; color:var(--text-muted);">Focus (min)</span>
                        <input type="number" id="focusDuration" class="select-input" value="25" style="width:80px; text-align:center;">
                    </div>
                    <div style="display:flex; flex-direction:column; gap:5px; align-items:flex-start;">
                        <span style="font-size:11px; color:var(--text-muted);">Break (min)</span>
                        <input type="number" id="breakDuration" class="select-input" value="5" style="width:80px; text-align:center;">
                    </div>
                    <div style="display:flex; flex-direction:column; gap:5px; align-items:flex-start;">
                        <span style="font-size:11px; color:var(--text-muted);">Soundscape</span>
                        <select id="soundSelect" class="select-input" style="width:140px;" onchange="focusMode.changeSound(this.value)">
                            <option value="none">Silent</option>
                            <option value="beats">Deep Focus (Beats)</option>
                            <option value="wind">Pink Noise</option>
                            <option value="white">White Noise</option>
                            <option value="brown">Brown Noise</option>
                            <option value="rain">Heavy Rain</option>
                            <option value="forest">Forest (Birds)</option>
                            <option value="night">Night (Crickets)</option>
                            <option value="ocean">Ocean Waves</option>
                            <option value="fan">Fan</option>
                        </select>
                    </div>
                </div>

                <div class="timer-circle" id="timerCircle">
                    <span id="timerDisplay" class="timer-time">25:00</span>
                    <span id="timerLabel" class="timer-label">Ready</span>
                </div>

                <div style="display:flex; justify-content:center; gap:10px; margin-bottom:30px; flex-wrap: wrap;">
                    <button class="btn btn-primary" id="btnStartFocus" onclick="focusMode.start('focus')" style="min-width:110px;">Start Focus</button>
                    <button class="btn btn-secondary" id="btnStartBreak" onclick="focusMode.start('break')" style="border-color:var(--success); color:var(--success); min-width:110px;">Start Break</button>
                    
                    <button class="btn btn-secondary" id="btnPause" onclick="focusMode.togglePause()" style="display:none; background:var(--bg-body); color:var(--warning); border-color:var(--warning); min-width:80px;">
                        <i class="fas fa-pause"></i> Pause
                    </button>
                    
                    <button class="btn btn-secondary btn-danger" onclick="focusMode.stop()">Stop</button>
                </div>

                <div class="idle-tracker">
                    <div style="text-align:left;">
                        <h4 style="color:var(--text-main); font-size:15px;"><i class="fas fa-hourglass-half"></i> Idle Time</h4>
                        <p style="color:var(--text-muted); font-size:11px;">Time spent online without timer running</p>
                    </div>
                    <div style="font-family:'Roboto Mono', monospace; font-size:24px; color:var(--warning);" id="idleDisplay">
                        00:00:00
                    </div>
                </div>
            </div>
        </div>

        <div id="community" class="view-container">
            <div style="display:grid; grid-template-columns: 1fr; gap:30px;">
                <div id="commBoard">
                    <div class="task-card">
                        <h3 style="color:var(--accent); margin-bottom:5px;"><i class="fas fa-trophy"></i> Live Leaderboard</h3>
                        <p style="font-size:12px; color:var(--text-muted); margin-bottom:10px;">Points are awarded for every completed task.</p>
                        <div class="leaderboard-container">
                            <table class="leaderboard-table" id="leaderboardTable">
                                <tr><td colspan="3" style="text-align:center; color:var(--text-muted);">Sign in to view live rankings.</td></tr>
                            </table>
                        </div>
                    </div>
                </div>
                <div id="groupChat" style="display:none; flex-direction:column; height: 100%;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <div>
                            <button class="btn btn-secondary" style="padding:4px 8px; font-size:12px;" onclick="app.leaveGroup()">← Back</button>
                            <strong id="chatTitle" style="margin-left:10px; font-size:16px;">Group</strong>
                        </div>
                    </div>
                    <div class="chat-layout">
                        <div class="chat-main">
                            <div class="chat-messages" id="chatMsgs"></div>
                            <div class="chat-input-area">
                                <input type="text" id="chatInput" class="main-input" placeholder="Type a message..." onkeydown="if(event.key==='Enter') app.sendMessage()">
                                <button class="btn btn-primary" onclick="app.sendMessage()"><i class="fas fa-paper-plane"></i></button>
                            </div>
                        </div>
                        <div class="chat-sidebar-panel">
                            <div style="font-size:12px; font-weight:bold; color:var(--text-muted); margin-bottom:10px;">ONLINE</div>
                            <div id="chatParticipants"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <div style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1000; display:none; align-items:center; justify-content:center; backdrop-filter: blur(5px);" id="authModal">
        <div style="background:var(--bg-sidebar); padding:30px; border-radius:16px; width:90%; max-width:400px; border:1px solid var(--border); text-align:center; position:relative;">
            <h2 style="margin-bottom:20px; color:var(--text-main);">Cloud Sync</h2>
            <form onsubmit="event.preventDefault(); app.login();">
                <input type="email" id="authEmail" class="main-input" style="border:1px solid var(--border); background:var(--bg-body); width:100%; margin-bottom:10px; border-radius:8px;" placeholder="Email" autocomplete="username">
                <input type="password" id="authPass" class="main-input" style="border:1px solid var(--border); background:var(--bg-body); width:100%; margin-bottom:20px; border-radius:8px;" placeholder="Password" autocomplete="current-password">
                
                <div style="margin-bottom: 20px; text-align: right;">
                    <a href="#" onclick="app.forgotPassword()" style="color: var(--accent); font-size: 13px; text-decoration: none;">Forgot Password?</a>
                </div>

                <div style="display:flex; gap:10px;">
                    <button type="submit" class="btn btn-primary" style="flex:1">Login</button>
                    <button type="button" class="btn btn-secondary" style="flex:1" onclick="app.register()">Sign Up</button>
                </div>
            </form>
            <button class="btn btn-icon" style="position:absolute; top:10px; right:10px; width:auto; height:auto; color:var(--text-muted);" onclick="document.getElementById('authModal').style.display='none'">✕</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, updateDoc, deleteDoc, doc, onSnapshot, query, where, writeBatch, orderBy, limit, getDocs, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCoCFw0hezldX3t33AYa1ytddYMuQCWliM",
            authDomain: "daily-todo-1e4ad.firebaseapp.com",
            projectId: "daily-todo-1e4ad",
            storageBucket: "daily-todo-1e4ad.firebasestorage.app",
            messagingSenderId: "629797690976",
            appId: "1:629797690976:web:fda66df1691eb920e12d05"
        };
        // 1. Register the Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(() => console.log("Service Worker Registered"))
                .catch(err => console.log("SW Registration Failed", err));
        }

        // 2. Request Notification Permission (For Alarms)
        if ("Notification" in window && Notification.permission !== "granted") {
            Notification.requestPermission();
        }
        const appInit = initializeApp(firebaseConfig);
        const auth = getAuth(appInit);
        const db = getFirestore(appInit);

        const state = {
            user: null,
            tasks: [],
            notes: [],
            focusLogs: JSON.parse(localStorage.getItem('focusLogs')) || [],
            history: JSON.parse(localStorage.getItem('taskHistory')) || ["Meeting", "Workout", "Study"],
            currentDate: new Date(),
            charts: {},
            customDesign: localStorage.getItem('customDesignCSS') || null,
            taskFilter: 'active',
            weather: { temp: '--', condition: 'Unknown' },
            subStreakTask: localStorage.getItem('subStreakTask') || '',
            idleSeconds: parseInt(localStorage.getItem('localIdleSeconds')) || 0,
            dailyGoal: parseInt(localStorage.getItem('dailyGoal')) || 3
        };

        window.app = {
            init: () => {
                app.updateClock();
                setInterval(app.updateClock, 1000 * 60);
                app.fetchWeather();
                document.getElementById('dateInput').valueAsDate = new Date();
                document.getElementById('dailyGoalInput').value = state.dailyGoal;
                
                if(state.customDesign) document.getElementById('dynamic-theme-style').textContent = state.customDesign;
                
                if(!state.user) {
                    state.notes = JSON.parse(localStorage.getItem('local_notes')) || [];
                    app.renderNotes();
                }

                window.addEventListener('storage', (e) => {
                    if (e.key === 'local_tasks' && !state.user) {
                        state.tasks = JSON.parse(e.newValue || "[]");
                        renderTasks();
                        if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
                    }
                });

                if("Notification" in window && Notification.permission !== 'granted') {
                    Notification.requestPermission();
                }
            },

            updateClock: () => {
                const now = new Date();
                const time = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                document.getElementById('clockDisplay').textContent = time;
            },

            fetchWeather: () => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(async (pos) => {
                        try {
                            const { latitude, longitude } = pos.coords;
                            const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);
                            const data = await res.json();
                            const temp = Math.round(data.current_weather.temperature);
                            document.getElementById('weatherDisplay').innerHTML = `<i class="fas fa-cloud-sun"></i> <span>${temp}${data.current_weather_units.temperature}</span>`;
                        } catch (e) { console.error("Weather Error", e); }
                    }, () => {
                        document.getElementById('weatherDisplay').innerHTML = `<span>Loc. Denied</span>`;
                    });
                }
            },

            generateRandomDesign: () => {
                const hue = Math.floor(Math.random() * 360);
                const sat = Math.floor(Math.random() * 40) + 20;
                const lit = Math.floor(Math.random() * 15) + 5;
                const fonts = ["'Inter', sans-serif", "'Playfair Display', serif", "'Roboto Mono', monospace", "'Comic Neue', cursive"];
                const font = fonts[Math.floor(Math.random() * fonts.length)];
                const css = `:root { --bg-body: hsl(${hue}, ${sat}%, ${lit}%); --bg-sidebar: hsl(${hue}, ${sat}%, ${lit + 5}%); --bg-card: hsl(${hue}, ${sat}%, ${lit + 10}%); --bg-input: hsl(${hue}, ${sat}%, ${lit + 5}%); --accent: hsl(${(hue + 180) % 360}, 70%, 50%); --font-main: ${font}; }`;
                document.getElementById('dynamic-theme-style').textContent = css;
                localStorage.setItem('customDesignCSS', css);
                state.customDesign = css;
            },

            toggleTheme: () => {
                const html = document.documentElement;
                const icon = document.getElementById('themeIcon');
                if (html.getAttribute('data-theme') === 'dark') {
                    html.setAttribute('data-theme', 'light');
                    icon.className = 'fas fa-sun';
                    document.getElementById('dynamic-theme-style').textContent = "";
                } else {
                    html.setAttribute('data-theme', 'dark');
                    icon.className = 'fas fa-moon';
                    if(state.customDesign) document.getElementById('dynamic-theme-style').textContent = state.customDesign;
                }
            },

            saveLifetime: async (showNotification = false) => {
                localStorage.setItem('local_tasks', JSON.stringify(state.tasks));
                localStorage.setItem('local_notes', JSON.stringify(state.notes));
                localStorage.setItem('localIdleSeconds', state.idleSeconds);
                localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));
                if (showNotification) {
                    if(state.user) { 
                        alert("Cloud Sync is active. Your data is saved automatically as you type."); 
                    } else { 
                        alert("Local data secured. Sign in to enable Cloud Sync."); 
                    }
                }
            },

            resetAllData: async () => {
                if(!confirm("⚠️ DANGER ZONE ⚠️\n\nThis will permanently DELETE ALL tasks, history, notes, and statistics.\n\nAre you sure?")) return;
                if(!confirm("Last chance: This cannot be undone. Confirm full data wipe?")) return;

                state.tasks = [];
                state.notes = [];
                state.focusLogs = [];
                state.history = ["Meeting", "Workout", "Study"]; 
                state.charts = {};
                state.idleSeconds = 0;
                localStorage.removeItem('local_tasks');
                localStorage.removeItem('local_notes');
                localStorage.removeItem('focusLogs');
                localStorage.setItem('taskHistory', JSON.stringify(state.history));
                localStorage.setItem('localIdleSeconds', 0);

                if(state.user) {
                    try {
                        const batch = writeBatch(db);
                        const qTasks = query(collection(db, 'tasks'), where('uid', '==', state.user.uid));
                        const snapTasks = await getDocs(qTasks);
                        snapTasks.docs.forEach(doc => { batch.delete(doc.ref); });
                        const qNotes = query(collection(db, 'notes'), where('uid', '==', state.user.uid));
                        const snapNotes = await getDocs(qNotes);
                        snapNotes.docs.forEach(doc => { batch.delete(doc.ref); });
                        await batch.commit();
                        await setDoc(doc(db, 'leaderboard', state.user.uid), {
                            username: state.user.email.split('@')[0],
                            score: 0,
                            lastActive: Date.now()
                        });
                        await setDoc(doc(db, 'timers', state.user.uid), {
                            status: 'idle', idleSeconds: 0, updatedAt: Date.now()
                        });
                        alert("Cloud data wiped successfully.");
                    } catch (e) { alert("Error wiping cloud data: " + e.message); }
                } else { alert("Local data wiped successfully."); }

                renderTasks();
                app.renderNotes();
                renderSuggestions();
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            backupData: () => {
                const data = { meta: { version: "5.0", date: new Date().toISOString() }, tasks: state.tasks, notes: state.notes, history: state.history };
                const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "TaskPro_Checkpoint_" + Date.now() + ".json";
                a.click();
            },

            restoreData: (input) => {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if(data.tasks && Array.isArray(data.tasks)) {
                            if(state.user) {
                                alert("Restoring to cloud... please wait.");
                                const batch = writeBatch(db);
                                data.tasks.forEach(t => {
                                    const { id, ...taskData } = t;
                                    const newDocRef = doc(collection(db, 'tasks'));
                                    batch.set(newDocRef, { ...taskData, uid: state.user.uid });
                                });
                                if(data.notes) {
                                    data.notes.forEach(n => {
                                        const { id, ...noteData } = n;
                                        const newNoteRef = doc(collection(db, 'notes'));
                                        batch.set(newNoteRef, { ...noteData, uid: state.user.uid });
                                    });
                                }
                                await batch.commit();
                                alert("Cloud restore successful!");
                            } else {
                                state.tasks = [...state.tasks, ...data.tasks];
                                if(data.notes) state.notes = [...state.notes, ...data.notes];
                                app.saveLifetime(true);
                                renderTasks();
                                app.renderNotes();
                            }
                        }
                    } catch(err) { alert("Invalid File Format"); console.error(err); }
                };
                reader.readAsText(file);
            },

            toggleSidebar: () => {
                document.getElementById('sidebar').classList.toggle('open');
                const overlay = document.getElementById('sidebarOverlay');
                overlay.style.display = overlay.style.display === 'block' ? 'none' : 'block';
            },

            switchTab: (id) => {
                document.querySelectorAll('.view-container').forEach(el => el.classList.remove('active'));
                document.querySelectorAll('.nav-link').forEach(el => el.classList.remove('active'));
                document.getElementById(id).classList.add('active');
                event.currentTarget.classList.add('active');
                document.getElementById('pageTitle').textContent = (id === 'notes' ? "My Notes" : id.charAt(0).toUpperCase() + id.slice(1));
                
                if(window.innerWidth <= 768) app.toggleSidebar();
                if(id === 'dashboard') app.renderDashboardCharts();
                if(id === 'calendar') renderCalendar();
                if(id === 'community') app.loadCommunity();
                if(id === 'focus') app.loadFocusTasks();
                if(id === 'notes') app.renderNotes();
            },

            toggleAuth: () => { if(state.user) signOut(auth); else document.getElementById('authModal').style.display = 'flex'; },
            
            login: async () => {
                try { await signInWithEmailAndPassword(auth, document.getElementById('authEmail').value, document.getElementById('authPass').value); document.getElementById('authModal').style.display='none'; } catch(e){alert(e.message);}
            },
            
            register: async () => {
                try { await createUserWithEmailAndPassword(auth, document.getElementById('authEmail').value, document.getElementById('authPass').value); document.getElementById('authModal').style.display='none'; } catch(e){alert(e.message);}
            },

            forgotPassword: async () => {
                const email = document.getElementById('authEmail').value;
                if(!email) { alert("Please enter your email address in the box first."); return; }
                try { await sendPasswordResetEmail(auth, email); alert("Password reset email sent! Check your inbox."); } catch(e) { alert("Error: " + e.message); }
            },

            setTaskFilter: (filter) => {
                state.taskFilter = filter;
                document.getElementById('filterActive').className = filter === 'active' ? 'btn btn-primary' : 'btn btn-secondary';
                document.getElementById('filterCompleted').className = filter === 'completed' ? 'btn btn-primary' : 'btn btn-secondary';
                renderTasks();
            },

            handleTaskSubmit: async () => {
                const id = document.getElementById('editTaskId').value;
                if(id) await app.updateTask(id); else await app.addTask();
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            addTask: async (title = null) => {
                const input = document.getElementById('taskInput');
                const text = title || input.value.trim();
                if(!text) return;

                if(!state.history.includes(text)) {
                    state.history.unshift(text);
                    if(state.history.length > 8) state.history.pop();
                    localStorage.setItem('taskHistory', JSON.stringify(state.history));
                    renderSuggestions();
                }

                const newTask = {
                    text,
                    completed: false,
                    date: document.getElementById('dateInput').value,
                    priority: document.getElementById('prioInput').value,
                    tags: (text.match(/#\w+/g) || []).map(t => t.replace('#','')),
                    subtasks: [],
                    createdAt: Date.now()
                };

                if(state.user) {
                    await addDoc(collection(db, 'tasks'), { ...newTask, uid: state.user.uid });
                } else {
                    newTask.id = 'local_' + Date.now();
                    state.tasks.push(newTask);
                    app.saveLifetime(false);
                    renderTasks();
                }
                if(!title) input.value = '';
            },

            startEdit: (id) => {
                const task = state.tasks.find(t => t.id === id);
                if(!task) return;
                document.getElementById('taskInput').value = task.text;
                document.getElementById('dateInput').value = task.date;
                document.getElementById('prioInput').value = task.priority;
                document.getElementById('editTaskId').value = task.id;
                const btn = document.getElementById('addUpdateBtn');
                btn.innerHTML = 'Update';
                btn.classList.replace('btn-primary', 'btn-secondary');
                document.getElementById('cancelEditBtn').style.display = 'inline-block';
            },

            updateTask: async (id) => {
                const text = document.getElementById('taskInput').value;
                const date = document.getElementById('dateInput').value;
                const priority = document.getElementById('prioInput').value;
                const tags = (text.match(/#\w+/g) || []).map(t => t.replace('#',''));
                
                const oldTask = state.tasks.find(t => t.id === id);
                const subtasks = oldTask ? (oldTask.subtasks || []) : [];

                if(state.user) {
                    await updateDoc(doc(db, 'tasks', id), { text, date, priority, tags, subtasks });
                } else {
                    const idx = state.tasks.findIndex(t => t.id === id);
                    if(idx !== -1) { state.tasks[idx] = { ...state.tasks[idx], text, date, priority, tags }; app.saveLifetime(false); renderTasks(); }
                }
                app.cancelEdit();
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            cancelEdit: () => {
                document.getElementById('taskInput').value = '';
                document.getElementById('editTaskId').value = '';
                const btn = document.getElementById('addUpdateBtn');
                btn.innerHTML = '<i class="fas fa-plus"></i> Add';
                btn.classList.replace('btn-secondary', 'btn-primary');
                document.getElementById('cancelEditBtn').style.display = 'none';
            },

            toggleTask: async (id) => {
                const task = state.tasks.find(t => t.id === id);
                const newVal = !task.completed;
                if(state.user) await updateDoc(doc(db, 'tasks', id), { completed: newVal });
                else { task.completed = newVal; app.saveLifetime(false); renderTasks(); }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            deleteTask: async (id) => {
                if(!confirm("Permanently delete?")) return;
                if(state.user) await deleteDoc(doc(db, 'tasks', id));
                else { state.tasks = state.tasks.filter(t => t.id !== id); app.saveLifetime(false); renderTasks(); }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            addSubtask: async (parentId) => {
                const input = document.getElementById(`sub-input-${parentId}`);
                if(!input.value.trim()) return;
                const task = state.tasks.find(t => t.id === parentId);
                const newSub = { id: Date.now(), text: input.value.trim(), completed: false };
                const subtasks = [...(task.subtasks||[]), newSub];
                if(state.user) await updateDoc(doc(db, 'tasks', parentId), { subtasks });
                else { task.subtasks = subtasks; app.saveLifetime(false); renderTasks(); }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },
            
            toggleSubtask: async (parentId, subId) => {
                const task = state.tasks.find(t => t.id === parentId);
                const subtasks = task.subtasks.map(s => s.id == subId ? {...s, completed: !s.completed} : s);
                if(state.user) await updateDoc(doc(db, 'tasks', parentId), { subtasks });
                else { task.subtasks = subtasks; app.saveLifetime(false); renderTasks(); }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            deleteSubtask: async (parentId, subId) => {
                const task = state.tasks.find(t => t.id === parentId);
                const subtasks = task.subtasks.filter(s => s.id != subId);
                if(state.user) await updateDoc(doc(db, 'tasks', parentId), { subtasks });
                else { task.subtasks = subtasks; app.saveLifetime(false); renderTasks(); }
                
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
            },

            addNote: async () => {
                const input = document.getElementById('noteInput');
                const content = input.value.trim();
                if(!content) return;
                
                const newNote = { content, createdAt: Date.now() };

                if(state.user) {
                    try {
                        await addDoc(collection(db, 'notes'), { ...newNote, uid: state.user.uid });
                        input.value = '';
                    } catch(e) {
                        alert("Error saving note: " + e.message);
                    }
                } else {
                    newNote.id = 'local_note_' + Date.now();
                    state.notes.unshift(newNote);
                    localStorage.setItem('local_notes', JSON.stringify(state.notes));
                    app.renderNotes();
                    input.value = '';
                }
            },

            deleteNote: async (id) => {
                if(!confirm("Permanently delete this note?")) return;
                if(state.user) {
                    await deleteDoc(doc(db, 'notes', id));
                } else {
                    state.notes = state.notes.filter(n => n.id !== id);
                    localStorage.setItem('local_notes', JSON.stringify(state.notes));
                    app.renderNotes();
                }
            },

            enableEditNote: (id) => {
                const note = state.notes.find(n => n.id === id);
                if(!note) return;
                const card = document.getElementById(`note-card-${id}`);
                const contentDiv = card.querySelector('.note-content');
                const currentText = note.content;
                contentDiv.innerHTML = `<textarea id="edit-note-input-${id}" class="main-input" style="width:100%; min-height:100px; background:var(--bg-body); border:1px solid var(--accent); resize:vertical;">${currentText}</textarea>`;
                const actionsDiv = card.querySelector('.note-header-actions');
                actionsDiv.innerHTML = `<button class="btn btn-primary" style="padding: 5px 10px; font-size: 12px;" onclick="app.saveEditedNote('${id}')">Save</button><button class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="app.renderNotes()">Cancel</button>`;
            },

            saveEditedNote: async (id) => {
                const input = document.getElementById(`edit-note-input-${id}`);
                const newContent = input.value.trim();
                if(!newContent) return;

                if(state.user) {
                    await updateDoc(doc(db, 'notes', id), { content: newContent });
                } else {
                    const idx = state.notes.findIndex(n => n.id === id);
                    if(idx !== -1) {
                        state.notes[idx].content = newContent;
                        localStorage.setItem('local_notes', JSON.stringify(state.notes));
                        app.renderNotes();
                    }
                }
            },

            renderNotes: () => {
                const list = document.getElementById('notesList');
                if(!list) return;
                const sortedNotes = [...state.notes].sort((a,b) => b.createdAt - a.createdAt);
                if(sortedNotes.length === 0) {
                    list.innerHTML = `<div style="text-align:center; color:var(--text-muted); margin-top:30px;"><i class="fas fa-pencil-alt" style="font-size:24px; margin-bottom:10px;"></i><br>No notes yet. Save your first thought!</div>`;
                    return;
                }
                list.innerHTML = sortedNotes.map(note => {
                    const dateObj = new Date(note.createdAt);
                    const dateStr = dateObj.toLocaleDateString() + ' ' + dateObj.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                    return `
                    <div class="note-card" id="note-card-${note.id}">
                        <div class="note-header-actions">
                            <button class="note-action-btn" onclick="app.enableEditNote('${note.id}')" title="Edit"><i class="fas fa-pencil"></i></button>
                            <button class="note-action-btn delete-btn" onclick="app.deleteNote('${note.id}')" title="Delete"><i class="fas fa-trash"></i></button>
                        </div>
                        <div class="note-content">${note.content}</div>
                        <div class="note-date">${dateStr}</div>
                    </div>`;
                }).join('');
            },

            changeMonth: (offset) => {
                state.currentDate.setMonth(state.currentDate.getMonth() + offset);
                renderCalendar();
            },
            selectDate: (dateStr) => {
                document.getElementById('calSelectedDate').textContent = new Date(dateStr).toDateString();
                const tasks = state.tasks.filter(t => t.date === dateStr);
                const html = tasks.length ? tasks.map(t => `<div style="padding:10px; background:var(--bg-body); margin-bottom:5px; border-radius:5px; border-left:3px solid var(--accent);">${t.text} ${t.completed?'(Done)':''}</div>`).join('') : '<div style="color:var(--text-muted)">No tasks.</div>';
                document.getElementById('calSelectedTasks').innerHTML = html;
                document.querySelectorAll('.cal-cell').forEach(c => c.classList.remove('selected'));
                const cell = document.querySelector(`.cal-cell[data-date="${dateStr}"]`);
                if(cell) cell.classList.add('selected');
            },

            syncLeaderboard: async () => {
                if (!state.user) return;
                const completedCount = state.tasks.filter(t => t.completed).length;
                const score = completedCount * 10;
                const username = state.user.email.split('@')[0];
                try {
                    await setDoc(doc(db, 'leaderboard', state.user.uid), { username: username, score: score, lastActive: Date.now() });
                } catch (e) { console.error("Leaderboard Sync Error:", e); }
            },

            loadCommunity: async () => {
                const boardTable = document.getElementById('leaderboardTable');
                boardTable.innerHTML = `<tr><td colspan="3" style="text-align:center; padding:20px;">Loading live scores...</td></tr>`;

                try {
                    const q = query(collection(db, 'leaderboard'), orderBy('score', 'desc'), limit(20));
                    const snapshot = await getDocs(q);
                    
                    let html = `<thead><tr><th style="width:60px">Rank</th><th>User</th><th style="text-align:right">Score</th></tr></thead><tbody>`;
                    let rank = 1;

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const isMe = state.user && doc.id === state.user.uid;
                        
                        let rankDisplay = `<span style="opacity:0.5">#${rank}</span>`;
                        if (rank === 1) rankDisplay = `<span class="rank-badge rank-1">1</span>`;
                        if (rank === 2) rankDisplay = `<span class="rank-badge rank-2">2</span>`;
                        if (rank === 3) rankDisplay = `<span class="rank-badge rank-3">3</span>`;
                        const rowStyle = isMe ? `background: rgba(32, 128, 132, 0.15); font-weight:bold; border-left: 3px solid var(--accent);` : ``;
                        html += `<tr style="${rowStyle}"><td>${rankDisplay}</td><td>${data.username} ${isMe ? '(You)' : ''}</td><td style="text-align:right; font-family:monospace; font-size:15px;">${data.score}</td></tr>`;
                        rank++;
                    });

                    if (snapshot.empty) html += `<tr><td colspan="3" style="text-align:center; color:var(--text-muted); padding:20px;">No players yet.</td></tr>`;
                    html += `</tbody>`;
                    boardTable.innerHTML = html;
                } catch (e) {
                    console.error(e);
                    boardTable.innerHTML = `<tr><td colspan="3" style="color:var(--danger); text-align:center;">Could not load leaderboard.<br>Sign in required.</td></tr>`;
                }
            },

            sendMessage: (isSys = false) => {
                const box = document.getElementById('chatMsgs');
                const input = document.getElementById('chatInput');
                const txt = isSys ? "Welcome to the group!" : input.value;
                if(!txt) return;
                const div = document.createElement('div');
                div.className = isSys ? 'chat-msg them' : 'chat-msg me';
                div.textContent = txt;
                box.appendChild(div);
                input.value = '';
                box.scrollTop = box.scrollHeight;
            },

            getStreak: (filterName = null) => {
                let streak = 0;
                let today = new Date();
                today.setHours(0,0,0,0);
                const getIsoDate = (d) => {
                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                };
                const cleanText = (txt) => txt.replace(/#\w+/g, '').trim();

                if(!filterName) {
                    const todayStr = getIsoDate(today);
                    const tasksToday = state.tasks.filter(t => t.date === todayStr);
                    if (tasksToday.length > 0 && tasksToday.every(t => t.completed)) streak++;
                    
                    let checkDate = new Date(today);
                    checkDate.setDate(checkDate.getDate() - 1);
                    while (true) {
                        const dateStr = getIsoDate(checkDate);
                        const tasksOnDate = state.tasks.filter(t => t.date === dateStr);
                        if (tasksOnDate.length === 0) break;
                        if (tasksOnDate.every(t => t.completed)) {
                            streak++;
                            checkDate.setDate(checkDate.getDate() - 1);
                        } else break;
                    }
                    return streak;
                } else {
                    const todayStr = getIsoDate(today);
                    const doneToday = state.tasks.some(t => t.date === todayStr && cleanText(t.text) === filterName && t.completed);
                    if(doneToday) streak++;

                    let checkDate = new Date(today);
                    checkDate.setDate(checkDate.getDate() - 1);
                    while(true) {
                        const dateStr = getIsoDate(checkDate);
                        const doneOnDate = state.tasks.some(t => t.date === dateStr && cleanText(t.text) === filterName && t.completed);
                        if (doneOnDate) { streak++; checkDate.setDate(checkDate.getDate() - 1); } else { break; }
                    }
                    return streak;
                }
            },

            updateSubStreak: () => {
                const select = document.getElementById('subStreakSelect');
                const val = select.value;
                state.subStreakTask = val;
                localStorage.setItem('subStreakTask', val);
                const count = val ? app.getStreak(val) : 0;
                document.getElementById('subStreakCount').textContent = count;
            },

            // New Goal Setting
            setDailyGoal: (val) => {
                state.dailyGoal = parseInt(val) || 3;
                localStorage.setItem('dailyGoal', state.dailyGoal);
                document.getElementById('goalTargetDisplay').textContent = state.dailyGoal + 'h';
                app.renderDashboardCharts(); // Re-render to update progress
            },

            // NEW: Reset All Focus Data
            resetFocusData: async () => {
                if(!confirm("Reset ALL focus timer history? This cannot be undone.")) return;
                state.focusLogs = [];
                localStorage.setItem('focusLogs', JSON.stringify([]));
                
                if(state.user) {
                    try {
                        const batch = writeBatch(db);
                        const q = query(collection(db, 'focus_sessions'), where('uid', '==', state.user.uid));
                        const snapshot = await getDocs(q);
                        snapshot.forEach(doc => batch.delete(doc.ref));
                        await batch.commit();
                    } catch(e) { console.error("Error clearing cloud logs", e); }
                }
                app.renderDashboardCharts();
            },

            // NEW: Edit specific task time (Adjustment)
            editTaskFocus: async (taskName) => {
                // Find current total duration for this task
                let currentDuration = 0;
                state.focusLogs.forEach(log => {
                    const name = log.taskTitle || 'Unknown Task';
                    // Match by name for aggregation consistency
                    if (name === taskName) currentDuration += (log.duration || 0);
                });

                const currentMins = Math.round(currentDuration / 60);
                const newVal = prompt(`Update total focus time for "${taskName}" (in minutes):`, currentMins);
                if (newVal === null) return;
                
                const newMins = parseInt(newVal);
                if (isNaN(newMins) || newMins < 0) return alert("Invalid time.");

                const diffSeconds = (newMins * 60) - currentDuration;
                if (Math.abs(diffSeconds) < 1) return; // No change

                // Create adjustment log
                const log = {
                    duration: diffSeconds,
                    timestamp: Date.now(),
                    taskTitle: taskName,
                    taskId: null, // manual adjustment
                    isAdjustment: true
                };

                state.focusLogs.push(log);
                localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));

                if(state.user) {
                     addDoc(collection(db, 'focus_sessions'), { 
                        uid: state.user.uid,
                        ...log
                    }).catch(e => console.error(e));
                }
                app.renderDashboardCharts();
            },

            // NEW: Reset specific task time
            resetTaskFocus: async (taskName) => {
                if(!confirm(`Remove all focus history for "${taskName}"?`)) return;
                
                // Filter out logs with this task title
                const logsToRemove = state.focusLogs.filter(log => (log.taskTitle || 'Unknown Task') === taskName);
                state.focusLogs = state.focusLogs.filter(log => (log.taskTitle || 'Unknown Task') !== taskName);
                localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));

                if(state.user) {
                    try {
                        const batch = writeBatch(db);
                        const q = query(collection(db, 'focus_sessions'), where('uid', '==', state.user.uid), where('taskTitle', '==', taskName));
                        const snapshot = await getDocs(q);
                        snapshot.forEach(doc => batch.delete(doc.ref));
                        await batch.commit();
                    } catch(e) { console.error(e); }
                }
                app.renderDashboardCharts();
            },

            renderDashboardCharts: () => {
                const timeFilter = document.getElementById('dashFilterTime').value;
                const tagFilter = document.getElementById('dashFilterTag').value;
                let filtered = state.tasks;
                const now = new Date();
                
                const currentStreak = app.getStreak(null);
                document.getElementById('streakCount').textContent = currentStreak;
                const streakIcon = document.getElementById('streakIcon');
                if(currentStreak > 0) {
                    streakIcon.style.opacity = '1'; streakIcon.style.color = '#f97316'; streakIcon.classList.add('fa-beat');
                } else {
                    streakIcon.style.opacity = '0.3'; streakIcon.style.color = 'var(--text-muted)'; streakIcon.classList.remove('fa-beat');
                }

                // ==========================================
                //  UPDATED FOCUS ANALYTICS LOGIC (THE FIX)
                // ==========================================
                
                let focusSeconds = 0;
                const logs = state.focusLogs || [];
                const taskStats = {}; // To hold accumulated time per task
                
                const validTaskIds = new Set(state.tasks.map(t => t.id));

                logs.forEach(log => {
                    // Check if linked task exists (if linked via ID)
                    if (log.taskId && !validTaskIds.has(log.taskId)) {
                        return; // Skip deleted task logs
                    }

                    const logDate = new Date(log.timestamp);
                    let include = false;
                    if(timeFilter === 'all') include = true;
                    else if(timeFilter === 'daily') include = logDate.toDateString() === now.toDateString();
                    else if(timeFilter === 'weekly') { const ago = new Date(); ago.setDate(now.getDate() - 7); include = logDate >= ago; }
                    else if(timeFilter === 'monthly') include = logDate.getMonth() === now.getMonth() && logDate.getFullYear() === now.getFullYear();
                    else if(timeFilter === 'yearly') include = logDate.getFullYear() === now.getFullYear();
                    
                    if(include) {
                        focusSeconds += (log.duration || 0);
                        
                        // Accumulate for specific task breakdown
                        // Prefer current task name if ID exists, else fallback to log title
                        let name = log.taskTitle || 'Unknown Task';
                        if (log.taskId) {
                            const currentTask = state.tasks.find(t => t.id === log.taskId);
                            if (currentTask) name = currentTask.text;
                        }
                        
                        taskStats[name] = (taskStats[name] || 0) + log.duration;
                    }
                });

                // Prevent negative time display if adjustments pushed it below zero
                if(focusSeconds < 0) focusSeconds = 0;

                const hrs = Math.floor(focusSeconds / 3600);
                const mins = Math.floor((focusSeconds % 3600) / 60);
                document.getElementById('focusTimeDisplay').textContent = `${hrs}h ${mins}m`;
                
                // Goal Calculation
                let goalProgress = 0;
                let displayPercent = "0%";
                
                if(timeFilter === 'daily') {
                    document.getElementById('focusTimeLabel').textContent = "Today";
                    const goalSecs = state.dailyGoal * 3600;
                    if (goalSecs > 0) {
                        goalProgress = (focusSeconds / goalSecs) * 100;
                        // PRECISION LOGIC
                        if (goalProgress > 0 && goalProgress < 1) {
                            displayPercent = goalProgress.toFixed(2) + "%";
                        } else {
                            displayPercent = Math.round(goalProgress) + "%";
                        }
                        if (goalProgress > 100) goalProgress = 100; // cap bar fill
                    }
                } else {
                    document.getElementById('focusTimeLabel').textContent = timeFilter === 'all' ? "Total" : timeFilter;
                    goalProgress = 0; 
                }
                
                document.getElementById('goalProgressBar').style.width = Math.min(goalProgress, 100) + '%';
                document.getElementById('goalPercentDisplay').textContent = displayPercent;

                // RENDER TASK BREAKDOWN LIST
                const taskListEl = document.getElementById('taskFocusList');
                // Filter out tasks with <= 0 duration (from adjustments)
                const sortedTasks = Object.entries(taskStats)
                    .filter(([_, dur]) => dur > 0)
                    .sort((a,b) => b[1] - a[1]); 
                
                if (sortedTasks.length === 0) {
                    taskListEl.innerHTML = `<div style="font-size:12px; color:var(--text-muted); font-style:italic;">No specific task data yet.</div>`;
                } else {
                    taskListEl.innerHTML = sortedTasks.map(([name, dur]) => {
                        const h = Math.floor(dur / 3600);
                        const m = Math.floor((dur % 3600) / 60);
                        // Escape quotes for onclick
                        const safeName = name.replace(/'/g, "\\'");
                        return `
                        <div class="focus-task-row">
                            <span class="focus-task-name">${name.length > 25 ? name.substring(0,25)+'...' : name}</span>
                            <span class="focus-task-time">${h > 0 ? h+'h ' : ''}${m}m</span>
                            <div class="focus-task-actions">
                                <i class="fas fa-pencil focus-icon-btn" onclick="app.editTaskFocus('${safeName}')" title="Edit Time"></i>
                                <i class="fas fa-trash focus-icon-btn" onclick="app.resetTaskFocus('${safeName}')" title="Remove from list"></i>
                            </div>
                        </div>`;
                    }).join('');
                }
                
                // End Focus Analytics Update

                const subSelect = document.getElementById('subStreakSelect');
                const cleanText = (txt) => txt.replace(/#\w+/g, '').trim();
                const allTaskNames = new Set([...state.history, ...state.tasks.map(t => cleanText(t.text))]);
                
                while(subSelect.options.length > 1) { subSelect.remove(1); }
                allTaskNames.forEach(name => {
                    if(!name) return;
                    const opt = document.createElement('option');
                    opt.value = name; opt.textContent = name;
                    if(name === state.subStreakTask) opt.selected = true;
                    subSelect.appendChild(opt);
                });
                app.updateSubStreak();

                if (timeFilter !== 'all') {
                    filtered = filtered.filter(t => {
                        const d = new Date(t.date);
                        if(timeFilter === 'daily') return d.toDateString() === now.toDateString();
                        if(timeFilter === 'weekly') { const ago = new Date(); ago.setDate(now.getDate() - 7); return d >= ago && d <= now; }
                        if(timeFilter === 'monthly') return d.getMonth() === now.getMonth();
                        if(timeFilter === 'yearly') return d.getFullYear() === now.getFullYear();
                        return true;
                    });
                }
                if (tagFilter !== 'all') filtered = filtered.filter(t => (t.tags||[]).includes(tagFilter));

                // FIXED: Subtask Counting Logic
                let totalCount = 0;
                let doneCount = 0;
                
                filtered.forEach(t => {
                    totalCount++; // The task itself
                    if(t.completed) doneCount++;
                    
                    if(t.subtasks && t.subtasks.length > 0) {
                        totalCount += t.subtasks.length;
                        doneCount += t.subtasks.filter(s => s.completed).length;
                    }
                });

                document.getElementById('dashTotal').textContent = totalCount;
                document.getElementById('dashDone').textContent = doneCount;
                document.getElementById('dashPending').textContent = totalCount - doneCount;

                const allTags = [...new Set(state.tasks.flatMap(t => t.tags || []))];
                const tagSelect = document.getElementById('dashFilterTag');
                if(tagSelect.options.length === 1) { 
                    allTags.forEach(tag => {
                        const opt = document.createElement('option'); opt.value = tag; opt.textContent = '#' + tag; tagSelect.appendChild(opt);
                    });
                }

                const ctx1 = document.getElementById('mainChart').getContext('2d');
                if(state.charts.main) state.charts.main.destroy();
                const labels = [], dataPoints = [];
                for(let i=6; i>=0; i--) {
                    const d = new Date(); d.setDate(d.getDate() - i);
                    const k = d.toISOString().split('T')[0];
                    labels.push(k.slice(5));
                    dataPoints.push(state.tasks.filter(t => t.date === k && t.completed).length);
                }
                state.charts.main = new Chart(ctx1, {
                    type: 'line',
                    data: { labels: labels, datasets: [{ label: 'Completed', data: dataPoints, borderColor: getComputedStyle(document.body).getPropertyValue('--accent'), tension: 0.4 }] },
                    options: { maintainAspectRatio: false, plugins: { legend: {display:false} } }
                });

                const ctx2 = document.getElementById('tagChart').getContext('2d');
                if(state.charts.tags) state.charts.tags.destroy();
                const tagCounts = {};
                filtered.forEach(t => (t.tags||[]).forEach(tag => tagCounts[tag] = (tagCounts[tag]||0)+1));
                state.charts.tags = new Chart(ctx2, {
                    type: 'doughnut',
                    data: { labels: Object.keys(tagCounts), datasets: [{ data: Object.values(tagCounts), backgroundColor: ['#208084', '#10b981', '#f59e0b', '#ef4444', '#6366f1'] }] },
                    options: { maintainAspectRatio: false }
                });
            },

            focusOnTask: (id) => { app.switchTab('focus'); document.getElementById('focusTaskSelect').value = id; },
            loadFocusTasks: () => {
                const sel = document.getElementById('focusTaskSelect');
                const currentVal = sel.value;
                sel.innerHTML = '<option value="">-- No specific task --</option>';
                state.tasks.filter(t => !t.completed).forEach(t => {
                    const opt = document.createElement('option'); opt.value = t.id; opt.textContent = t.text;
                    if(t.id === currentVal) opt.selected = true;
                    sel.appendChild(opt);
                });
            }
        };

        // =======================================================
        //  AUDIO ENGINE & FOCUS TIMER LOGIC
        // =======================================================

        const AudioEngine = {
            ctx: null,
            activeNodes: [],
            gainNode: null,
            alarmInterval: null,
            alarmOsc: null,

            init: () => {
                if(!AudioEngine.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    AudioEngine.ctx = new AudioContext();
                }
                if(AudioEngine.ctx.state === 'suspended') {
                    AudioEngine.ctx.resume();
                }
            },

            playBeep: (type) => {
                AudioEngine.init();
                const t = AudioEngine.ctx.currentTime;
                const osc = AudioEngine.ctx.createOscillator();
                const gain = AudioEngine.ctx.createGain();
                osc.connect(gain);
                gain.connect(AudioEngine.ctx.destination);

                if (type === 'start') {
                    osc.frequency.setValueAtTime(440, t);
                    osc.frequency.exponentialRampToValueAtTime(880, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                    osc.start(t);
                    osc.stop(t + 0.5);
                }
            },

            // NEW: Continuous Alarm Function
            playAlarm: () => {
                AudioEngine.init();
                // Stop any existing alarm
                if(AudioEngine.alarmInterval) clearInterval(AudioEngine.alarmInterval);
                
                const playPulse = () => {
                    const t = AudioEngine.ctx.currentTime;
                    const osc = AudioEngine.ctx.createOscillator();
                    const gain = AudioEngine.ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(AudioEngine.ctx.destination);
                    
                    osc.frequency.setValueAtTime(880, t); // A5
                    osc.frequency.setValueAtTime(1100, t + 0.2); // Just a bit higher
                    
                    gain.gain.setValueAtTime(0.2, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                    
                    osc.type = 'square';
                    osc.start(t);
                    osc.stop(t + 0.5);
                };

                // Play immediately
                playPulse();
                // Repeat every second
                AudioEngine.alarmInterval = setInterval(playPulse, 1000);
            },

            stopAlarm: () => {
                if(AudioEngine.alarmInterval) {
                    clearInterval(AudioEngine.alarmInterval);
                    AudioEngine.alarmInterval = null;
                }
            },

            createNoiseBuffer: () => {
                const bufferSize = AudioEngine.ctx.sampleRate * 2; 
                const buffer = AudioEngine.ctx.createBuffer(1, bufferSize, AudioEngine.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                return buffer;
            },

            playBackground: (type) => {
                AudioEngine.stopBackground();
                if(type === 'none') return;
                AudioEngine.init();
                const t = AudioEngine.ctx.currentTime;
                
                AudioEngine.gainNode = AudioEngine.ctx.createGain();
                AudioEngine.gainNode.gain.setValueAtTime(0.1, t);
                AudioEngine.gainNode.connect(AudioEngine.ctx.destination);

                // NOISE BASED
                if (['white', 'wind', 'rain', 'brown', 'ocean', 'fan'].includes(type)) {
                    const noise = AudioEngine.ctx.createBufferSource();
                    noise.buffer = AudioEngine.createNoiseBuffer();
                    noise.loop = true;
                    
                    let finalNode = noise;

                    if (type === 'wind' || type === 'rain') { 
                        const filter = AudioEngine.ctx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = type === 'wind' ? 400 : 800; 
                        noise.connect(filter);
                        finalNode = filter;
                    } 
                    if (type === 'brown') {
                         const filter = AudioEngine.ctx.createBiquadFilter();
                         filter.type = 'lowpass';
                         filter.frequency.value = 150;
                         noise.connect(filter);
                         finalNode = filter;
                    }
                    if (type === 'ocean') {
                        const filter = AudioEngine.ctx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.Q.value = 1;
                        noise.connect(filter);
                        // LFO for waves
                        const lfo = AudioEngine.ctx.createOscillator();
                        lfo.type = 'sine';
                        lfo.frequency.value = 0.1; 
                        const lfoGain = AudioEngine.ctx.createGain();
                        lfoGain.gain.value = 300;
                        lfo.connect(lfoGain);
                        lfoGain.connect(filter.frequency);
                        filter.frequency.setValueAtTime(400, t);
                        lfo.start();
                        AudioEngine.activeNodes.push(lfo);
                        finalNode = filter;
                    }
                    if (type === 'fan') {
                        const filter = AudioEngine.ctx.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.value = 150;
                        filter.Q.value = 2;
                        noise.connect(filter);
                        finalNode = filter;
                    }

                    finalNode.connect(AudioEngine.gainNode);
                    noise.start();
                    AudioEngine.activeNodes.push(noise);
                } 
                
                if (type === 'beats') {
                    const osc1 = AudioEngine.ctx.createOscillator();
                    const osc2 = AudioEngine.ctx.createOscillator();
                    osc1.frequency.value = 200;
                    osc2.frequency.value = 205; 
                    osc1.connect(AudioEngine.gainNode);
                    osc2.connect(AudioEngine.gainNode);
                    osc1.start(); osc2.start();
                    AudioEngine.activeNodes.push(osc1, osc2);
                }

                if (type === 'forest') {
                    // Improved Forest: Pink Noise (Leaves) + Random Chirps
                    const noise = AudioEngine.ctx.createBufferSource();
                    noise.buffer = AudioEngine.createNoiseBuffer();
                    noise.loop = true;
                    const filter = AudioEngine.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 500;
                    noise.connect(filter);
                    const noiseGain = AudioEngine.ctx.createGain();
                    noiseGain.gain.value = 0.3;
                    filter.connect(noiseGain);
                    noiseGain.connect(AudioEngine.gainNode);
                    noise.start();
                    AudioEngine.activeNodes.push(noise);

                    // Random Bird Chirps
                    const playChirp = () => {
                        if(AudioEngine.activeNodes.length === 0) return; // Stopped
                        const osc = AudioEngine.ctx.createOscillator();
                        const g = AudioEngine.ctx.createGain();
                        osc.frequency.setValueAtTime(1500 + Math.random()*1000, AudioEngine.ctx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(1000 + Math.random()*500, AudioEngine.ctx.currentTime + 0.1);
                        g.gain.setValueAtTime(0, AudioEngine.ctx.currentTime);
                        g.gain.linearRampToValueAtTime(0.1, AudioEngine.ctx.currentTime + 0.05);
                        g.gain.linearRampToValueAtTime(0, AudioEngine.ctx.currentTime + 0.2);
                        osc.connect(g);
                        g.connect(AudioEngine.gainNode);
                        osc.start(); osc.stop(AudioEngine.ctx.currentTime + 0.2);
                        setTimeout(playChirp, 1000 + Math.random() * 4000);
                    };
                    playChirp();
                }

                if (type === 'night') {
                    // Crickets: High freq Osc with amplitude modulation
                    const car = AudioEngine.ctx.createOscillator();
                    car.frequency.value = 4500;
                    const mod = AudioEngine.ctx.createOscillator();
                    mod.type = 'square';
                    mod.frequency.value = 10;
                    const modGain = AudioEngine.ctx.createGain();
                    modGain.gain.value = 1000;
                    
                    const masterG = AudioEngine.ctx.createGain();
                    masterG.gain.value = 0.05;
                    
                    mod.connect(masterG.gain);
                    car.connect(masterG);
                    masterG.connect(AudioEngine.gainNode);
                    
                    car.start(); mod.start();
                    AudioEngine.activeNodes.push(car, mod);
                }
            },

            stopBackground: () => {
                AudioEngine.activeNodes.forEach(n => { try{n.stop();}catch(e){}});
                AudioEngine.activeNodes = [];
                if(AudioEngine.gainNode) { AudioEngine.gainNode.disconnect(); AudioEngine.gainNode = null; }
            }
        };

        window.focusMode = {
            timerInterval: null,
            status: 'idle', // 'idle', 'running', 'paused', 'break'
            pausedType: null, // to track if we paused 'focus' or 'break'
            endTime: 0,
            remainingAtPause: 0,
            totalDuration: 0,
            alarmTimeout: null,
            
            syncTimerState: async () => {
                if(!state.user) return;
                const data = {
                    status: focusMode.status,
                    endTime: focusMode.endTime,
                    remainingAtPause: focusMode.remainingAtPause,
                    totalDuration: focusMode.totalDuration,
                    pausedType: focusMode.pausedType || null,
                    updatedAt: Date.now()
                };
                try {
                    await setDoc(doc(db, 'timers', state.user.uid), data, {merge: true});
                } catch(e) { console.error("Sync timer error", e); }
            },

            start: (type) => {
                // Check if we are resuming the correct type
                if (focusMode.status === 'paused' && focusMode.pausedType === type) {
                    focusMode.endTime = Date.now() + focusMode.remainingAtPause;
                    focusMode.status = type;
                    focusMode.pausedType = null;
                } else {
                    // Start fresh
                    let mins = parseInt(document.getElementById(type === 'focus' ? 'focusDuration' : 'breakDuration').value) || 25;
                    focusMode.totalDuration = mins * 60 * 1000;
                    focusMode.endTime = Date.now() + focusMode.totalDuration;
                    focusMode.status = type;
                    focusMode.pausedType = null;
                }

                focusMode.updateUI(true);
                AudioEngine.playBeep('start');
                AudioEngine.playBackground(document.getElementById('soundSelect').value);
                
                focusMode.runLoop();
                focusMode.syncTimerState();
            },

            togglePause: () => {
                if(focusMode.status === 'idle') return;

                if (focusMode.status === 'paused') {
                    // Resume based on what was paused
                    const resumeType = focusMode.pausedType || 'focus';
                    focusMode.start(resumeType);
                } else {
                    // Pause
                    const now = Date.now();
                    focusMode.remainingAtPause = Math.max(0, focusMode.endTime - now);
                    focusMode.pausedType = focusMode.status; // Remember what we paused
                    focusMode.status = 'paused';
                    
                    focusMode.updateUI(false);
                    AudioEngine.stopBackground();
                    clearInterval(focusMode.timerInterval);
                    focusMode.syncTimerState();
                }
            },

            stop: () => {
                // Feature: Ask to complete task on manual stop
                const taskId = document.getElementById('focusTaskSelect').value;
                if(taskId) {
                    const task = state.tasks.find(t => t.id === taskId);
                    if(task && !task.completed) {
                        if(confirm(`Timer stopped. Mark '${task.text}' as completed?`)) {
                            app.toggleTask(taskId);
                        }
                    }
                }
                focusMode.reset();
            },

            complete: () => {
                clearInterval(focusMode.timerInterval);
                AudioEngine.stopBackground();
                
                // SAVE SESSION LOG
                if (focusMode.status === 'focus') {
                    const durationSec = focusMode.totalDuration / 1000;
                    const taskId = document.getElementById('focusTaskSelect').value;
                    const task = state.tasks.find(t => t.id === taskId);
                    
                    const log = { 
                        duration: durationSec, 
                        timestamp: Date.now(),
                        taskId: taskId || null, 
                        taskTitle: task ? task.text : null 
                    };
                    
                    state.focusLogs.push(log);
                    // Critical for sync: save local too
                    localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));
                    
                    if(state.user) {
                         addDoc(collection(db, 'focus_sessions'), { 
                            uid: state.user.uid,
                            ...log
                        }).then(() => console.log("Session Synced")).catch(e => console.error("Sync Fail", e));
                    }
                    
                    if(taskId) app.toggleTask(taskId);
                }

                focusMode.status = 'idle';
                focusMode.updateUI(false);
                document.getElementById('timerDisplay').textContent = "00:00";
                document.getElementById('timerLabel').textContent = "Done";
                
                focusMode.syncTimerState();
                if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();

                // START ALARM UI
                AudioEngine.playAlarm();
                document.getElementById('alarmModal').style.display = 'flex';

                // Stop automatically after 10 seconds
                if(focusMode.alarmTimeout) clearTimeout(focusMode.alarmTimeout);
                focusMode.alarmTimeout = setTimeout(() => {
                    focusMode.stopAlarmUI();
                }, 10000);
            },

            stopAlarmUI: () => {
                document.getElementById('alarmModal').style.display = 'none';
                AudioEngine.stopAlarm();
                if(focusMode.alarmTimeout) clearTimeout(focusMode.alarmTimeout);
            },

            reset: () => {
                clearInterval(focusMode.timerInterval);
                AudioEngine.stopAlarm();
                document.getElementById('alarmModal').style.display = 'none';
                
                focusMode.status = 'idle';
                focusMode.pausedType = null;
                AudioEngine.stopBackground();
                focusMode.updateUI(false);
                
                let mins = parseInt(document.getElementById('focusDuration').value) || 25;
                const m = mins.toString().padStart(2,'0');
                document.getElementById('timerDisplay').textContent = `${m}:00`;
                document.getElementById('timerLabel').textContent = "Ready";
                focusMode.syncTimerState();
            },

            runLoop: () => {
                clearInterval(focusMode.timerInterval);
                focusMode.timerInterval = setInterval(() => {
                    const now = Date.now();
                    const diff = focusMode.endTime - now;
                    
                    if (diff <= 0) {
                        focusMode.complete();
                    } else {
                        const m = Math.floor(diff / 60000).toString().padStart(2,'0');
                        const s = Math.floor((diff % 60000) / 1000).toString().padStart(2,'0');
                        document.getElementById('timerDisplay').textContent = `${m}:${s}`;
                    }
                }, 1000);
            },

            updateUI: (isRunning) => {
                const circle = document.getElementById('timerCircle');
                const btnPause = document.getElementById('btnPause');
                const btnFocus = document.getElementById('btnStartFocus');
                const btnBreak = document.getElementById('btnStartBreak');

                circle.className = 'timer-circle'; 
                
                if (focusMode.status === 'focus') circle.classList.add('focus-mode', 'timer-active');
                if (focusMode.status === 'break') circle.classList.add('break-mode', 'timer-active');
                if (focusMode.status === 'paused') circle.classList.add('paused', 'timer-active');

                if (focusMode.status === 'idle') {
                    btnFocus.style.display = 'inline-block';
                    btnBreak.style.display = 'inline-block';
                    btnPause.style.display = 'none';
                } else {
                    btnFocus.style.display = focusMode.status === 'focus' ? 'inline-block' : 'none';
                    btnBreak.style.display = focusMode.status === 'break' ? 'inline-block' : 'none';
                    btnPause.style.display = 'inline-block';
                    btnPause.innerHTML = focusMode.status === 'paused' ? '<i class="fas fa-play"></i> Resume' : '<i class="fas fa-pause"></i> Pause';
                    
                    const label = focusMode.status === 'focus' ? "Focusing..." : (focusMode.status === 'break' ? "On Break" : "Paused");
                    document.getElementById('timerLabel').textContent = label;
                }
            },
            
            changeSound: (newSound) => {
                if(focusMode.status === 'focus' || focusMode.status === 'break') {
                    AudioEngine.playBackground(newSound);
                }
            }
        };

        // IDLE TRACKER
        let lastIdleSync = Date.now();

        setInterval(() => {
            if(focusMode.status === 'idle' || focusMode.status === 'paused') {
                state.idleSeconds++;
                const hrs = Math.floor(state.idleSeconds / 3600).toString().padStart(2,'0');
                const mins = Math.floor((state.idleSeconds % 3600) / 60).toString().padStart(2,'0');
                const secs = (state.idleSeconds % 60).toString().padStart(2,'0');
                document.getElementById('idleDisplay').textContent = `${hrs}:${mins}:${secs}`;
                localStorage.setItem('localIdleSeconds', state.idleSeconds);

                if(state.user && Date.now() - lastIdleSync > 10000) {
                    setDoc(doc(db, 'timers', state.user.uid), { 
                        idleSeconds: state.idleSeconds 
                    }, { merge: true });
                    lastIdleSync = Date.now();
                }
            }
        }, 1000);

        // SYNC LISTENER
        onAuthStateChanged(auth, (user) => {
            if(user) {
                state.user = user;
                document.getElementById('authBtn').textContent = "Sign Out";
                document.getElementById('syncDot').style.background = "var(--success)";
                document.getElementById('syncText').textContent = "Cloud Active";
                
                const qTasks = query(collection(db, 'tasks'), where('uid', '==', user.uid));
                onSnapshot(qTasks, (snap) => {
                    state.tasks = snap.docs.map(d => ({id: d.id, ...d.data()}));
                    renderTasks();
                    if(document.getElementById('dashboard').classList.contains('active')) app.renderDashboardCharts();
                    if(document.getElementById('calendar').classList.contains('active')) renderCalendar();
                    app.syncLeaderboard();
                });

                const qNotes = query(collection(db, 'notes'), where('uid', '==', user.uid));
                onSnapshot(qNotes, (snap) => {
                    state.notes = snap.docs.map(d => ({id: d.id, ...d.data()}));
                    if(document.getElementById('notes').classList.contains('active')) app.renderNotes();
                });

                // FIXED: Focus Logs Sync with FORCE UPDATE
                const qSessions = query(collection(db, 'focus_sessions'), where('uid', '==', user.uid));
                onSnapshot(qSessions, (snap) => {
                    // Update State
                    state.focusLogs = snap.docs.map(d => d.data());
                    // Critical: Update Local Storage to persist sync across refreshes
                    localStorage.setItem('focusLogs', JSON.stringify(state.focusLogs));
                    // Force Render immediately
                    app.renderDashboardCharts();
                });
                
                onSnapshot(doc(db, 'timers', user.uid), (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        if(data.idleSeconds > state.idleSeconds) state.idleSeconds = data.idleSeconds;

                        if(data.status && data.updatedAt > (focusMode.lastLocalUpdate || 0)) {
                             if (data.status !== focusMode.status || Math.abs(data.endTime - focusMode.endTime) > 2000) {
                                 focusMode.status = data.status;
                                 focusMode.endTime = data.endTime;
                                 focusMode.remainingAtPause = data.remainingAtPause;
                                 focusMode.totalDuration = data.totalDuration;
                                 focusMode.pausedType = data.pausedType;
                                 
                                 focusMode.updateUI(data.status === 'focus' || data.status === 'break');
                                 if(data.status === 'focus' || data.status === 'break') {
                                     focusMode.runLoop();
                                 } else {
                                     clearInterval(focusMode.timerInterval);
                                     if(data.status === 'idle') {
                                         document.getElementById('timerDisplay').textContent = "00:00";
                                     } else if (data.status === 'paused') {
                                         const diff = data.remainingAtPause;
                                         const m = Math.floor(diff / 60000).toString().padStart(2,'0');
                                         const s = Math.floor((diff % 60000) / 1000).toString().padStart(2,'0');
                                         document.getElementById('timerDisplay').textContent = `${m}:${s}`;
                                     }
                                 }
                             }
                        }
                    }
                });

            } else {
                state.user = null;
                document.getElementById('authBtn').textContent = "Sign In";
                document.getElementById('syncDot').style.background = "var(--warning)";
                document.getElementById('syncText').textContent = "Offline";
                state.tasks = JSON.parse(localStorage.getItem('local_tasks')) || [];
                state.notes = JSON.parse(localStorage.getItem('local_notes')) || [];
                state.focusLogs = JSON.parse(localStorage.getItem('focusLogs')) || [];
                renderTasks();
                app.renderNotes();
            }
        });

        // RENDERING
        function renderTasks() {
            const list = document.getElementById('taskList');
            list.innerHTML = "";
            const filter = state.taskFilter; 
            const visibleTasks = state.tasks.filter(t => filter === 'completed' ? t.completed : !t.completed);
            visibleTasks.forEach(task => {
                const subsHtml = (task.subtasks||[]).map(s => `<div class="subtask-row"><input type="checkbox" ${s.completed ? 'checked' : ''} onchange="app.toggleSubtask('${task.id}', '${s.id}')"><span style="text-decoration:${s.completed?'line-through':'none'}; opacity:${s.completed?0.5:1}; flex:1; color:var(--text-muted);">${s.text}</span><button class="btn btn-icon btn-danger" style="width:20px;height:20px;padding:0;font-size:10px;" onclick="app.deleteSubtask('${task.id}', '${s.id}')"><i class="fas fa-times"></i></button></div>`).join('');
                const tagsHtml = (task.tags||[]).map(t=>`<span class="tag">#${t}</span>`).join('');
                const html = `<div class="task-card priority-${task.priority}"><div class="task-header"><input type="checkbox" class="checkbox" ${task.completed ? 'checked' : ''} onchange="app.toggleTask('${task.id}')"><div class="task-content"><div class="task-title" style="text-decoration: ${task.completed ? 'line-through' : 'none'}">${task.text.replace(/#\w+/g,'')} ${tagsHtml}</div><div class="task-meta"><i class="far fa-calendar"></i> ${task.date} • ${task.priority.toUpperCase()}</div></div><div style="display:flex;gap:5px;"><button class="btn btn-icon" onclick="app.focusOnTask('${task.id}')"><i class="fas fa-stopwatch"></i></button><button class="btn btn-icon" onclick="app.startEdit('${task.id}')"><i class="fas fa-pencil"></i></button><button class="btn btn-icon btn-danger" onclick="app.deleteTask('${task.id}')"><i class="fas fa-trash"></i></button></div></div><div class="subtasks">${subsHtml}<div class="subtask-row"><input id="sub-input-${task.id}" placeholder="+ Subtask" style="background:transparent;border:none;color:var(--text-muted);width:100%;outline:none;font-size:13px;" onkeydown="if(event.key==='Enter') app.addSubtask('${task.id}')"></div></div></div>`;
                list.insertAdjacentHTML('beforeend', html);
            });
            if(visibleTasks.length === 0) list.innerHTML = `<div style="text-align:center;color:var(--text-muted);margin-top:20px;">No ${filter} tasks found.</div>`;
        }

        function renderCalendar() {
            const grid = document.getElementById('calGrid');
            grid.innerHTML = `<div class="cal-day-header">Sun</div><div class="cal-day-header">Mon</div><div class="cal-day-header">Tue</div><div class="cal-day-header">Wed</div><div class="cal-day-header">Thu</div><div class="cal-day-header">Fri</div><div class="cal-day-header">Sat</div>`;
            const year = state.currentDate.getFullYear();
            const month = state.currentDate.getMonth();
            document.getElementById('calMonthYear').textContent = new Date(year, month).toLocaleString('default', { month: 'long', year: 'numeric' });
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            for(let i=0; i<firstDay; i++) grid.insertAdjacentHTML('beforeend', `<div></div>`);
            for(let d=1; d<=daysInMonth; d++) {
                const dateStr = `${year}-${String(month+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
                const isToday = dateStr === new Date().toISOString().split('T')[0];
                const dayTasks = state.tasks.filter(t => t.date === dateStr);
                const dots = dayTasks.map(t => `<div class="cal-task-dot ${t.completed?'done':''}">${t.text}</div>`).join('');
                grid.insertAdjacentHTML('beforeend', `<div class="cal-cell ${isToday ? 'today' : ''}" data-date="${dateStr}" onclick="app.selectDate('${dateStr}')"><div class="cal-date">${d}</div>${dots}</div>`);
            }
        }

        function renderSuggestions() {
            document.getElementById('suggestionsBox').innerHTML = state.history.map(h => `<div class="suggestion-chip" onclick="app.addTask('${h}')">${h} <span onclick="event.stopPropagation();app.removeSuggestion('${h}')">×</span></div>`).join('');
        }
        window.app.removeSuggestion = (t) => { state.history = state.history.filter(h => h !== t); localStorage.setItem('taskHistory', JSON.stringify(state.history)); renderSuggestions(); };

        app.init();
        renderSuggestions();
    </script>
    <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(reg => console.log('Service Worker registered!', reg))
        .catch(err => console.log('Registration failed!', err));
    });
  }
</script> 
</body>
</html>
